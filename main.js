/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// node_modules/xml2js/lib/defaults.js
var require_defaults = __commonJS({
  "node_modules/xml2js/lib/defaults.js"(exports) {
    (function() {
      exports.defaults = {
        "0.1": {
          explicitCharkey: false,
          trim: true,
          normalize: true,
          normalizeTags: false,
          attrkey: "@",
          charkey: "#",
          explicitArray: false,
          ignoreAttrs: false,
          mergeAttrs: false,
          explicitRoot: false,
          validator: null,
          xmlns: false,
          explicitChildren: false,
          childkey: "@@",
          charsAsChildren: false,
          includeWhiteChars: false,
          async: false,
          strict: true,
          attrNameProcessors: null,
          attrValueProcessors: null,
          tagNameProcessors: null,
          valueProcessors: null,
          emptyTag: ""
        },
        "0.2": {
          explicitCharkey: false,
          trim: false,
          normalize: false,
          normalizeTags: false,
          attrkey: "$",
          charkey: "_",
          explicitArray: true,
          ignoreAttrs: false,
          mergeAttrs: false,
          explicitRoot: true,
          validator: null,
          xmlns: false,
          explicitChildren: false,
          preserveChildrenOrder: false,
          childkey: "$$",
          charsAsChildren: false,
          includeWhiteChars: false,
          async: false,
          strict: true,
          attrNameProcessors: null,
          attrValueProcessors: null,
          tagNameProcessors: null,
          valueProcessors: null,
          rootName: "root",
          xmldec: {
            "version": "1.0",
            "encoding": "UTF-8",
            "standalone": true
          },
          doctype: null,
          renderOpts: {
            "pretty": true,
            "indent": "  ",
            "newline": "\n"
          },
          headless: false,
          chunkSize: 1e4,
          emptyTag: "",
          cdata: false
        }
      };
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/Utility.js
var require_Utility = __commonJS({
  "node_modules/xmlbuilder/lib/Utility.js"(exports, module2) {
    (function() {
      var assign, getValue, isArray, isEmpty, isFunction, isObject, isPlainObject, slice = [].slice, hasProp = {}.hasOwnProperty;
      assign = function() {
        var i, key, len, source, sources, target;
        target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        if (isFunction(Object.assign)) {
          Object.assign.apply(null, arguments);
        } else {
          for (i = 0, len = sources.length; i < len; i++) {
            source = sources[i];
            if (source != null) {
              for (key in source) {
                if (!hasProp.call(source, key))
                  continue;
                target[key] = source[key];
              }
            }
          }
        }
        return target;
      };
      isFunction = function(val) {
        return !!val && Object.prototype.toString.call(val) === "[object Function]";
      };
      isObject = function(val) {
        var ref;
        return !!val && ((ref = typeof val) === "function" || ref === "object");
      };
      isArray = function(val) {
        if (isFunction(Array.isArray)) {
          return Array.isArray(val);
        } else {
          return Object.prototype.toString.call(val) === "[object Array]";
        }
      };
      isEmpty = function(val) {
        var key;
        if (isArray(val)) {
          return !val.length;
        } else {
          for (key in val) {
            if (!hasProp.call(val, key))
              continue;
            return false;
          }
          return true;
        }
      };
      isPlainObject = function(val) {
        var ctor, proto;
        return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && typeof ctor === "function" && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
      };
      getValue = function(obj) {
        if (isFunction(obj.valueOf)) {
          return obj.valueOf();
        } else {
          return obj;
        }
      };
      module2.exports.assign = assign;
      module2.exports.isFunction = isFunction;
      module2.exports.isObject = isObject;
      module2.exports.isArray = isArray;
      module2.exports.isEmpty = isEmpty;
      module2.exports.isPlainObject = isPlainObject;
      module2.exports.getValue = getValue;
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDOMImplementation.js
var require_XMLDOMImplementation = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDOMImplementation.js"(exports, module2) {
    (function() {
      var XMLDOMImplementation;
      module2.exports = XMLDOMImplementation = function() {
        function XMLDOMImplementation2() {
        }
        XMLDOMImplementation2.prototype.hasFeature = function(feature, version) {
          return true;
        };
        XMLDOMImplementation2.prototype.createDocumentType = function(qualifiedName, publicId, systemId) {
          throw new Error("This DOM method is not implemented.");
        };
        XMLDOMImplementation2.prototype.createDocument = function(namespaceURI, qualifiedName, doctype) {
          throw new Error("This DOM method is not implemented.");
        };
        XMLDOMImplementation2.prototype.createHTMLDocument = function(title) {
          throw new Error("This DOM method is not implemented.");
        };
        XMLDOMImplementation2.prototype.getFeature = function(feature, version) {
          throw new Error("This DOM method is not implemented.");
        };
        return XMLDOMImplementation2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js
var require_XMLDOMErrorHandler = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js"(exports, module2) {
    (function() {
      var XMLDOMErrorHandler;
      module2.exports = XMLDOMErrorHandler = function() {
        function XMLDOMErrorHandler2() {
        }
        XMLDOMErrorHandler2.prototype.handleError = function(error) {
          throw new Error(error);
        };
        return XMLDOMErrorHandler2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDOMStringList.js
var require_XMLDOMStringList = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDOMStringList.js"(exports, module2) {
    (function() {
      var XMLDOMStringList;
      module2.exports = XMLDOMStringList = function() {
        function XMLDOMStringList2(arr) {
          this.arr = arr || [];
        }
        Object.defineProperty(XMLDOMStringList2.prototype, "length", {
          get: function() {
            return this.arr.length;
          }
        });
        XMLDOMStringList2.prototype.item = function(index) {
          return this.arr[index] || null;
        };
        XMLDOMStringList2.prototype.contains = function(str) {
          return this.arr.indexOf(str) !== -1;
        };
        return XMLDOMStringList2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDOMConfiguration.js
var require_XMLDOMConfiguration = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDOMConfiguration.js"(exports, module2) {
    (function() {
      var XMLDOMConfiguration, XMLDOMErrorHandler, XMLDOMStringList;
      XMLDOMErrorHandler = require_XMLDOMErrorHandler();
      XMLDOMStringList = require_XMLDOMStringList();
      module2.exports = XMLDOMConfiguration = function() {
        function XMLDOMConfiguration2() {
          var clonedSelf;
          this.defaultParams = {
            "canonical-form": false,
            "cdata-sections": false,
            "comments": false,
            "datatype-normalization": false,
            "element-content-whitespace": true,
            "entities": true,
            "error-handler": new XMLDOMErrorHandler(),
            "infoset": true,
            "validate-if-schema": false,
            "namespaces": true,
            "namespace-declarations": true,
            "normalize-characters": false,
            "schema-location": "",
            "schema-type": "",
            "split-cdata-sections": true,
            "validate": false,
            "well-formed": true
          };
          this.params = clonedSelf = Object.create(this.defaultParams);
        }
        Object.defineProperty(XMLDOMConfiguration2.prototype, "parameterNames", {
          get: function() {
            return new XMLDOMStringList(Object.keys(this.defaultParams));
          }
        });
        XMLDOMConfiguration2.prototype.getParameter = function(name) {
          if (this.params.hasOwnProperty(name)) {
            return this.params[name];
          } else {
            return null;
          }
        };
        XMLDOMConfiguration2.prototype.canSetParameter = function(name, value) {
          return true;
        };
        XMLDOMConfiguration2.prototype.setParameter = function(name, value) {
          if (value != null) {
            return this.params[name] = value;
          } else {
            return delete this.params[name];
          }
        };
        return XMLDOMConfiguration2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/NodeType.js
var require_NodeType = __commonJS({
  "node_modules/xmlbuilder/lib/NodeType.js"(exports, module2) {
    (function() {
      module2.exports = {
        Element: 1,
        Attribute: 2,
        Text: 3,
        CData: 4,
        EntityReference: 5,
        EntityDeclaration: 6,
        ProcessingInstruction: 7,
        Comment: 8,
        Document: 9,
        DocType: 10,
        DocumentFragment: 11,
        NotationDeclaration: 12,
        Declaration: 201,
        Raw: 202,
        AttributeDeclaration: 203,
        ElementDeclaration: 204,
        Dummy: 205
      };
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLAttribute.js
var require_XMLAttribute = __commonJS({
  "node_modules/xmlbuilder/lib/XMLAttribute.js"(exports, module2) {
    (function() {
      var NodeType, XMLAttribute, XMLNode;
      NodeType = require_NodeType();
      XMLNode = require_XMLNode();
      module2.exports = XMLAttribute = function() {
        function XMLAttribute2(parent, name, value) {
          this.parent = parent;
          if (this.parent) {
            this.options = this.parent.options;
            this.stringify = this.parent.stringify;
          }
          if (name == null) {
            throw new Error("Missing attribute name. " + this.debugInfo(name));
          }
          this.name = this.stringify.name(name);
          this.value = this.stringify.attValue(value);
          this.type = NodeType.Attribute;
          this.isId = false;
          this.schemaTypeInfo = null;
        }
        Object.defineProperty(XMLAttribute2.prototype, "nodeType", {
          get: function() {
            return this.type;
          }
        });
        Object.defineProperty(XMLAttribute2.prototype, "ownerElement", {
          get: function() {
            return this.parent;
          }
        });
        Object.defineProperty(XMLAttribute2.prototype, "textContent", {
          get: function() {
            return this.value;
          },
          set: function(value) {
            return this.value = value || "";
          }
        });
        Object.defineProperty(XMLAttribute2.prototype, "namespaceURI", {
          get: function() {
            return "";
          }
        });
        Object.defineProperty(XMLAttribute2.prototype, "prefix", {
          get: function() {
            return "";
          }
        });
        Object.defineProperty(XMLAttribute2.prototype, "localName", {
          get: function() {
            return this.name;
          }
        });
        Object.defineProperty(XMLAttribute2.prototype, "specified", {
          get: function() {
            return true;
          }
        });
        XMLAttribute2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLAttribute2.prototype.toString = function(options) {
          return this.options.writer.attribute(this, this.options.writer.filterOptions(options));
        };
        XMLAttribute2.prototype.debugInfo = function(name) {
          name = name || this.name;
          if (name == null) {
            return "parent: <" + this.parent.name + ">";
          } else {
            return "attribute: {" + name + "}, parent: <" + this.parent.name + ">";
          }
        };
        XMLAttribute2.prototype.isEqualNode = function(node) {
          if (node.namespaceURI !== this.namespaceURI) {
            return false;
          }
          if (node.prefix !== this.prefix) {
            return false;
          }
          if (node.localName !== this.localName) {
            return false;
          }
          if (node.value !== this.value) {
            return false;
          }
          return true;
        };
        return XMLAttribute2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLNamedNodeMap.js
var require_XMLNamedNodeMap = __commonJS({
  "node_modules/xmlbuilder/lib/XMLNamedNodeMap.js"(exports, module2) {
    (function() {
      var XMLNamedNodeMap;
      module2.exports = XMLNamedNodeMap = function() {
        function XMLNamedNodeMap2(nodes) {
          this.nodes = nodes;
        }
        Object.defineProperty(XMLNamedNodeMap2.prototype, "length", {
          get: function() {
            return Object.keys(this.nodes).length || 0;
          }
        });
        XMLNamedNodeMap2.prototype.clone = function() {
          return this.nodes = null;
        };
        XMLNamedNodeMap2.prototype.getNamedItem = function(name) {
          return this.nodes[name];
        };
        XMLNamedNodeMap2.prototype.setNamedItem = function(node) {
          var oldNode;
          oldNode = this.nodes[node.nodeName];
          this.nodes[node.nodeName] = node;
          return oldNode || null;
        };
        XMLNamedNodeMap2.prototype.removeNamedItem = function(name) {
          var oldNode;
          oldNode = this.nodes[name];
          delete this.nodes[name];
          return oldNode || null;
        };
        XMLNamedNodeMap2.prototype.item = function(index) {
          return this.nodes[Object.keys(this.nodes)[index]] || null;
        };
        XMLNamedNodeMap2.prototype.getNamedItemNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented.");
        };
        XMLNamedNodeMap2.prototype.setNamedItemNS = function(node) {
          throw new Error("This DOM method is not implemented.");
        };
        XMLNamedNodeMap2.prototype.removeNamedItemNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented.");
        };
        return XMLNamedNodeMap2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLElement.js
var require_XMLElement = __commonJS({
  "node_modules/xmlbuilder/lib/XMLElement.js"(exports, module2) {
    (function() {
      var NodeType, XMLAttribute, XMLElement, XMLNamedNodeMap, XMLNode, getValue, isFunction, isObject, ref, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      ref = require_Utility(), isObject = ref.isObject, isFunction = ref.isFunction, getValue = ref.getValue;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      XMLAttribute = require_XMLAttribute();
      XMLNamedNodeMap = require_XMLNamedNodeMap();
      module2.exports = XMLElement = function(superClass) {
        extend(XMLElement2, superClass);
        function XMLElement2(parent, name, attributes) {
          var child, j, len, ref1;
          XMLElement2.__super__.constructor.call(this, parent);
          if (name == null) {
            throw new Error("Missing element name. " + this.debugInfo());
          }
          this.name = this.stringify.name(name);
          this.type = NodeType.Element;
          this.attribs = {};
          this.schemaTypeInfo = null;
          if (attributes != null) {
            this.attribute(attributes);
          }
          if (parent.type === NodeType.Document) {
            this.isRoot = true;
            this.documentObject = parent;
            parent.rootObject = this;
            if (parent.children) {
              ref1 = parent.children;
              for (j = 0, len = ref1.length; j < len; j++) {
                child = ref1[j];
                if (child.type === NodeType.DocType) {
                  child.name = this.name;
                  break;
                }
              }
            }
          }
        }
        Object.defineProperty(XMLElement2.prototype, "tagName", {
          get: function() {
            return this.name;
          }
        });
        Object.defineProperty(XMLElement2.prototype, "namespaceURI", {
          get: function() {
            return "";
          }
        });
        Object.defineProperty(XMLElement2.prototype, "prefix", {
          get: function() {
            return "";
          }
        });
        Object.defineProperty(XMLElement2.prototype, "localName", {
          get: function() {
            return this.name;
          }
        });
        Object.defineProperty(XMLElement2.prototype, "id", {
          get: function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        });
        Object.defineProperty(XMLElement2.prototype, "className", {
          get: function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        });
        Object.defineProperty(XMLElement2.prototype, "classList", {
          get: function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        });
        Object.defineProperty(XMLElement2.prototype, "attributes", {
          get: function() {
            if (!this.attributeMap || !this.attributeMap.nodes) {
              this.attributeMap = new XMLNamedNodeMap(this.attribs);
            }
            return this.attributeMap;
          }
        });
        XMLElement2.prototype.clone = function() {
          var att, attName, clonedSelf, ref1;
          clonedSelf = Object.create(this);
          if (clonedSelf.isRoot) {
            clonedSelf.documentObject = null;
          }
          clonedSelf.attribs = {};
          ref1 = this.attribs;
          for (attName in ref1) {
            if (!hasProp.call(ref1, attName))
              continue;
            att = ref1[attName];
            clonedSelf.attribs[attName] = att.clone();
          }
          clonedSelf.children = [];
          this.children.forEach(function(child) {
            var clonedChild;
            clonedChild = child.clone();
            clonedChild.parent = clonedSelf;
            return clonedSelf.children.push(clonedChild);
          });
          return clonedSelf;
        };
        XMLElement2.prototype.attribute = function(name, value) {
          var attName, attValue;
          if (name != null) {
            name = getValue(name);
          }
          if (isObject(name)) {
            for (attName in name) {
              if (!hasProp.call(name, attName))
                continue;
              attValue = name[attName];
              this.attribute(attName, attValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            if (this.options.keepNullAttributes && value == null) {
              this.attribs[name] = new XMLAttribute(this, name, "");
            } else if (value != null) {
              this.attribs[name] = new XMLAttribute(this, name, value);
            }
          }
          return this;
        };
        XMLElement2.prototype.removeAttribute = function(name) {
          var attName, j, len;
          if (name == null) {
            throw new Error("Missing attribute name. " + this.debugInfo());
          }
          name = getValue(name);
          if (Array.isArray(name)) {
            for (j = 0, len = name.length; j < len; j++) {
              attName = name[j];
              delete this.attribs[attName];
            }
          } else {
            delete this.attribs[name];
          }
          return this;
        };
        XMLElement2.prototype.toString = function(options) {
          return this.options.writer.element(this, this.options.writer.filterOptions(options));
        };
        XMLElement2.prototype.att = function(name, value) {
          return this.attribute(name, value);
        };
        XMLElement2.prototype.a = function(name, value) {
          return this.attribute(name, value);
        };
        XMLElement2.prototype.getAttribute = function(name) {
          if (this.attribs.hasOwnProperty(name)) {
            return this.attribs[name].value;
          } else {
            return null;
          }
        };
        XMLElement2.prototype.setAttribute = function(name, value) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getAttributeNode = function(name) {
          if (this.attribs.hasOwnProperty(name)) {
            return this.attribs[name];
          } else {
            return null;
          }
        };
        XMLElement2.prototype.setAttributeNode = function(newAttr) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.removeAttributeNode = function(oldAttr) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getElementsByTagName = function(name) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getAttributeNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.setAttributeNS = function(namespaceURI, qualifiedName, value) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.removeAttributeNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getAttributeNodeNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.setAttributeNodeNS = function(newAttr) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.hasAttribute = function(name) {
          return this.attribs.hasOwnProperty(name);
        };
        XMLElement2.prototype.hasAttributeNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.setIdAttribute = function(name, isId) {
          if (this.attribs.hasOwnProperty(name)) {
            return this.attribs[name].isId;
          } else {
            return isId;
          }
        };
        XMLElement2.prototype.setIdAttributeNS = function(namespaceURI, localName, isId) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.setIdAttributeNode = function(idAttr, isId) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getElementsByTagName = function(tagname) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getElementsByClassName = function(classNames) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.isEqualNode = function(node) {
          var i, j, ref1;
          if (!XMLElement2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
            return false;
          }
          if (node.namespaceURI !== this.namespaceURI) {
            return false;
          }
          if (node.prefix !== this.prefix) {
            return false;
          }
          if (node.localName !== this.localName) {
            return false;
          }
          if (node.attribs.length !== this.attribs.length) {
            return false;
          }
          for (i = j = 0, ref1 = this.attribs.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j) {
            if (!this.attribs[i].isEqualNode(node.attribs[i])) {
              return false;
            }
          }
          return true;
        };
        return XMLElement2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLCharacterData.js
var require_XMLCharacterData = __commonJS({
  "node_modules/xmlbuilder/lib/XMLCharacterData.js"(exports, module2) {
    (function() {
      var XMLCharacterData, XMLNode, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLCharacterData = function(superClass) {
        extend(XMLCharacterData2, superClass);
        function XMLCharacterData2(parent) {
          XMLCharacterData2.__super__.constructor.call(this, parent);
          this.value = "";
        }
        Object.defineProperty(XMLCharacterData2.prototype, "data", {
          get: function() {
            return this.value;
          },
          set: function(value) {
            return this.value = value || "";
          }
        });
        Object.defineProperty(XMLCharacterData2.prototype, "length", {
          get: function() {
            return this.value.length;
          }
        });
        Object.defineProperty(XMLCharacterData2.prototype, "textContent", {
          get: function() {
            return this.value;
          },
          set: function(value) {
            return this.value = value || "";
          }
        });
        XMLCharacterData2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLCharacterData2.prototype.substringData = function(offset, count) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData2.prototype.appendData = function(arg) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData2.prototype.insertData = function(offset, arg) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData2.prototype.deleteData = function(offset, count) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData2.prototype.replaceData = function(offset, count, arg) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData2.prototype.isEqualNode = function(node) {
          if (!XMLCharacterData2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
            return false;
          }
          if (node.data !== this.data) {
            return false;
          }
          return true;
        };
        return XMLCharacterData2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLCData.js
var require_XMLCData = __commonJS({
  "node_modules/xmlbuilder/lib/XMLCData.js"(exports, module2) {
    (function() {
      var NodeType, XMLCData, XMLCharacterData, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLCharacterData = require_XMLCharacterData();
      module2.exports = XMLCData = function(superClass) {
        extend(XMLCData2, superClass);
        function XMLCData2(parent, text) {
          XMLCData2.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error("Missing CDATA text. " + this.debugInfo());
          }
          this.name = "#cdata-section";
          this.type = NodeType.CData;
          this.value = this.stringify.cdata(text);
        }
        XMLCData2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLCData2.prototype.toString = function(options) {
          return this.options.writer.cdata(this, this.options.writer.filterOptions(options));
        };
        return XMLCData2;
      }(XMLCharacterData);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLComment.js
var require_XMLComment = __commonJS({
  "node_modules/xmlbuilder/lib/XMLComment.js"(exports, module2) {
    (function() {
      var NodeType, XMLCharacterData, XMLComment, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLCharacterData = require_XMLCharacterData();
      module2.exports = XMLComment = function(superClass) {
        extend(XMLComment2, superClass);
        function XMLComment2(parent, text) {
          XMLComment2.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error("Missing comment text. " + this.debugInfo());
          }
          this.name = "#comment";
          this.type = NodeType.Comment;
          this.value = this.stringify.comment(text);
        }
        XMLComment2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLComment2.prototype.toString = function(options) {
          return this.options.writer.comment(this, this.options.writer.filterOptions(options));
        };
        return XMLComment2;
      }(XMLCharacterData);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDeclaration.js
var require_XMLDeclaration = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDeclaration.js"(exports, module2) {
    (function() {
      var NodeType, XMLDeclaration, XMLNode, isObject, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      isObject = require_Utility().isObject;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module2.exports = XMLDeclaration = function(superClass) {
        extend(XMLDeclaration2, superClass);
        function XMLDeclaration2(parent, version, encoding, standalone) {
          var ref;
          XMLDeclaration2.__super__.constructor.call(this, parent);
          if (isObject(version)) {
            ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;
          }
          if (!version) {
            version = "1.0";
          }
          this.type = NodeType.Declaration;
          this.version = this.stringify.xmlVersion(version);
          if (encoding != null) {
            this.encoding = this.stringify.xmlEncoding(encoding);
          }
          if (standalone != null) {
            this.standalone = this.stringify.xmlStandalone(standalone);
          }
        }
        XMLDeclaration2.prototype.toString = function(options) {
          return this.options.writer.declaration(this, this.options.writer.filterOptions(options));
        };
        return XMLDeclaration2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDAttList.js
var require_XMLDTDAttList = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDAttList.js"(exports, module2) {
    (function() {
      var NodeType, XMLDTDAttList, XMLNode, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module2.exports = XMLDTDAttList = function(superClass) {
        extend(XMLDTDAttList2, superClass);
        function XMLDTDAttList2(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          XMLDTDAttList2.__super__.constructor.call(this, parent);
          if (elementName == null) {
            throw new Error("Missing DTD element name. " + this.debugInfo());
          }
          if (attributeName == null) {
            throw new Error("Missing DTD attribute name. " + this.debugInfo(elementName));
          }
          if (!attributeType) {
            throw new Error("Missing DTD attribute type. " + this.debugInfo(elementName));
          }
          if (!defaultValueType) {
            throw new Error("Missing DTD attribute default. " + this.debugInfo(elementName));
          }
          if (defaultValueType.indexOf("#") !== 0) {
            defaultValueType = "#" + defaultValueType;
          }
          if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
            throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(elementName));
          }
          if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
            throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(elementName));
          }
          this.elementName = this.stringify.name(elementName);
          this.type = NodeType.AttributeDeclaration;
          this.attributeName = this.stringify.name(attributeName);
          this.attributeType = this.stringify.dtdAttType(attributeType);
          if (defaultValue) {
            this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
          }
          this.defaultValueType = defaultValueType;
        }
        XMLDTDAttList2.prototype.toString = function(options) {
          return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(options));
        };
        return XMLDTDAttList2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDEntity.js
var require_XMLDTDEntity = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDEntity.js"(exports, module2) {
    (function() {
      var NodeType, XMLDTDEntity, XMLNode, isObject, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      isObject = require_Utility().isObject;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module2.exports = XMLDTDEntity = function(superClass) {
        extend(XMLDTDEntity2, superClass);
        function XMLDTDEntity2(parent, pe, name, value) {
          XMLDTDEntity2.__super__.constructor.call(this, parent);
          if (name == null) {
            throw new Error("Missing DTD entity name. " + this.debugInfo(name));
          }
          if (value == null) {
            throw new Error("Missing DTD entity value. " + this.debugInfo(name));
          }
          this.pe = !!pe;
          this.name = this.stringify.name(name);
          this.type = NodeType.EntityDeclaration;
          if (!isObject(value)) {
            this.value = this.stringify.dtdEntityValue(value);
            this.internal = true;
          } else {
            if (!value.pubID && !value.sysID) {
              throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(name));
            }
            if (value.pubID && !value.sysID) {
              throw new Error("System identifier is required for a public external entity. " + this.debugInfo(name));
            }
            this.internal = false;
            if (value.pubID != null) {
              this.pubID = this.stringify.dtdPubID(value.pubID);
            }
            if (value.sysID != null) {
              this.sysID = this.stringify.dtdSysID(value.sysID);
            }
            if (value.nData != null) {
              this.nData = this.stringify.dtdNData(value.nData);
            }
            if (this.pe && this.nData) {
              throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(name));
            }
          }
        }
        Object.defineProperty(XMLDTDEntity2.prototype, "publicId", {
          get: function() {
            return this.pubID;
          }
        });
        Object.defineProperty(XMLDTDEntity2.prototype, "systemId", {
          get: function() {
            return this.sysID;
          }
        });
        Object.defineProperty(XMLDTDEntity2.prototype, "notationName", {
          get: function() {
            return this.nData || null;
          }
        });
        Object.defineProperty(XMLDTDEntity2.prototype, "inputEncoding", {
          get: function() {
            return null;
          }
        });
        Object.defineProperty(XMLDTDEntity2.prototype, "xmlEncoding", {
          get: function() {
            return null;
          }
        });
        Object.defineProperty(XMLDTDEntity2.prototype, "xmlVersion", {
          get: function() {
            return null;
          }
        });
        XMLDTDEntity2.prototype.toString = function(options) {
          return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(options));
        };
        return XMLDTDEntity2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDElement.js
var require_XMLDTDElement = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDElement.js"(exports, module2) {
    (function() {
      var NodeType, XMLDTDElement, XMLNode, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module2.exports = XMLDTDElement = function(superClass) {
        extend(XMLDTDElement2, superClass);
        function XMLDTDElement2(parent, name, value) {
          XMLDTDElement2.__super__.constructor.call(this, parent);
          if (name == null) {
            throw new Error("Missing DTD element name. " + this.debugInfo());
          }
          if (!value) {
            value = "(#PCDATA)";
          }
          if (Array.isArray(value)) {
            value = "(" + value.join(",") + ")";
          }
          this.name = this.stringify.name(name);
          this.type = NodeType.ElementDeclaration;
          this.value = this.stringify.dtdElementValue(value);
        }
        XMLDTDElement2.prototype.toString = function(options) {
          return this.options.writer.dtdElement(this, this.options.writer.filterOptions(options));
        };
        return XMLDTDElement2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDNotation.js
var require_XMLDTDNotation = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDNotation.js"(exports, module2) {
    (function() {
      var NodeType, XMLDTDNotation, XMLNode, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module2.exports = XMLDTDNotation = function(superClass) {
        extend(XMLDTDNotation2, superClass);
        function XMLDTDNotation2(parent, name, value) {
          XMLDTDNotation2.__super__.constructor.call(this, parent);
          if (name == null) {
            throw new Error("Missing DTD notation name. " + this.debugInfo(name));
          }
          if (!value.pubID && !value.sysID) {
            throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(name));
          }
          this.name = this.stringify.name(name);
          this.type = NodeType.NotationDeclaration;
          if (value.pubID != null) {
            this.pubID = this.stringify.dtdPubID(value.pubID);
          }
          if (value.sysID != null) {
            this.sysID = this.stringify.dtdSysID(value.sysID);
          }
        }
        Object.defineProperty(XMLDTDNotation2.prototype, "publicId", {
          get: function() {
            return this.pubID;
          }
        });
        Object.defineProperty(XMLDTDNotation2.prototype, "systemId", {
          get: function() {
            return this.sysID;
          }
        });
        XMLDTDNotation2.prototype.toString = function(options) {
          return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(options));
        };
        return XMLDTDNotation2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDocType.js
var require_XMLDocType = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDocType.js"(exports, module2) {
    (function() {
      var NodeType, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLNamedNodeMap, XMLNode, isObject, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      isObject = require_Utility().isObject;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDNotation = require_XMLDTDNotation();
      XMLNamedNodeMap = require_XMLNamedNodeMap();
      module2.exports = XMLDocType = function(superClass) {
        extend(XMLDocType2, superClass);
        function XMLDocType2(parent, pubID, sysID) {
          var child, i, len, ref, ref1, ref2;
          XMLDocType2.__super__.constructor.call(this, parent);
          this.type = NodeType.DocType;
          if (parent.children) {
            ref = parent.children;
            for (i = 0, len = ref.length; i < len; i++) {
              child = ref[i];
              if (child.type === NodeType.Element) {
                this.name = child.name;
                break;
              }
            }
          }
          this.documentObject = parent;
          if (isObject(pubID)) {
            ref1 = pubID, pubID = ref1.pubID, sysID = ref1.sysID;
          }
          if (sysID == null) {
            ref2 = [pubID, sysID], sysID = ref2[0], pubID = ref2[1];
          }
          if (pubID != null) {
            this.pubID = this.stringify.dtdPubID(pubID);
          }
          if (sysID != null) {
            this.sysID = this.stringify.dtdSysID(sysID);
          }
        }
        Object.defineProperty(XMLDocType2.prototype, "entities", {
          get: function() {
            var child, i, len, nodes, ref;
            nodes = {};
            ref = this.children;
            for (i = 0, len = ref.length; i < len; i++) {
              child = ref[i];
              if (child.type === NodeType.EntityDeclaration && !child.pe) {
                nodes[child.name] = child;
              }
            }
            return new XMLNamedNodeMap(nodes);
          }
        });
        Object.defineProperty(XMLDocType2.prototype, "notations", {
          get: function() {
            var child, i, len, nodes, ref;
            nodes = {};
            ref = this.children;
            for (i = 0, len = ref.length; i < len; i++) {
              child = ref[i];
              if (child.type === NodeType.NotationDeclaration) {
                nodes[child.name] = child;
              }
            }
            return new XMLNamedNodeMap(nodes);
          }
        });
        Object.defineProperty(XMLDocType2.prototype, "publicId", {
          get: function() {
            return this.pubID;
          }
        });
        Object.defineProperty(XMLDocType2.prototype, "systemId", {
          get: function() {
            return this.sysID;
          }
        });
        Object.defineProperty(XMLDocType2.prototype, "internalSubset", {
          get: function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        });
        XMLDocType2.prototype.element = function(name, value) {
          var child;
          child = new XMLDTDElement(this, name, value);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          var child;
          child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.entity = function(name, value) {
          var child;
          child = new XMLDTDEntity(this, false, name, value);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.pEntity = function(name, value) {
          var child;
          child = new XMLDTDEntity(this, true, name, value);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.notation = function(name, value) {
          var child;
          child = new XMLDTDNotation(this, name, value);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.toString = function(options) {
          return this.options.writer.docType(this, this.options.writer.filterOptions(options));
        };
        XMLDocType2.prototype.ele = function(name, value) {
          return this.element(name, value);
        };
        XMLDocType2.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
        };
        XMLDocType2.prototype.ent = function(name, value) {
          return this.entity(name, value);
        };
        XMLDocType2.prototype.pent = function(name, value) {
          return this.pEntity(name, value);
        };
        XMLDocType2.prototype.not = function(name, value) {
          return this.notation(name, value);
        };
        XMLDocType2.prototype.up = function() {
          return this.root() || this.documentObject;
        };
        XMLDocType2.prototype.isEqualNode = function(node) {
          if (!XMLDocType2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
            return false;
          }
          if (node.name !== this.name) {
            return false;
          }
          if (node.publicId !== this.publicId) {
            return false;
          }
          if (node.systemId !== this.systemId) {
            return false;
          }
          return true;
        };
        return XMLDocType2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLRaw.js
var require_XMLRaw = __commonJS({
  "node_modules/xmlbuilder/lib/XMLRaw.js"(exports, module2) {
    (function() {
      var NodeType, XMLNode, XMLRaw, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLNode = require_XMLNode();
      module2.exports = XMLRaw = function(superClass) {
        extend(XMLRaw2, superClass);
        function XMLRaw2(parent, text) {
          XMLRaw2.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error("Missing raw text. " + this.debugInfo());
          }
          this.type = NodeType.Raw;
          this.value = this.stringify.raw(text);
        }
        XMLRaw2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLRaw2.prototype.toString = function(options) {
          return this.options.writer.raw(this, this.options.writer.filterOptions(options));
        };
        return XMLRaw2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLText.js
var require_XMLText = __commonJS({
  "node_modules/xmlbuilder/lib/XMLText.js"(exports, module2) {
    (function() {
      var NodeType, XMLCharacterData, XMLText, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLCharacterData = require_XMLCharacterData();
      module2.exports = XMLText = function(superClass) {
        extend(XMLText2, superClass);
        function XMLText2(parent, text) {
          XMLText2.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error("Missing element text. " + this.debugInfo());
          }
          this.name = "#text";
          this.type = NodeType.Text;
          this.value = this.stringify.text(text);
        }
        Object.defineProperty(XMLText2.prototype, "isElementContentWhitespace", {
          get: function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        });
        Object.defineProperty(XMLText2.prototype, "wholeText", {
          get: function() {
            var next, prev, str;
            str = "";
            prev = this.previousSibling;
            while (prev) {
              str = prev.data + str;
              prev = prev.previousSibling;
            }
            str += this.data;
            next = this.nextSibling;
            while (next) {
              str = str + next.data;
              next = next.nextSibling;
            }
            return str;
          }
        });
        XMLText2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLText2.prototype.toString = function(options) {
          return this.options.writer.text(this, this.options.writer.filterOptions(options));
        };
        XMLText2.prototype.splitText = function(offset) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLText2.prototype.replaceWholeText = function(content) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        return XMLText2;
      }(XMLCharacterData);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLProcessingInstruction.js
var require_XMLProcessingInstruction = __commonJS({
  "node_modules/xmlbuilder/lib/XMLProcessingInstruction.js"(exports, module2) {
    (function() {
      var NodeType, XMLCharacterData, XMLProcessingInstruction, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLCharacterData = require_XMLCharacterData();
      module2.exports = XMLProcessingInstruction = function(superClass) {
        extend(XMLProcessingInstruction2, superClass);
        function XMLProcessingInstruction2(parent, target, value) {
          XMLProcessingInstruction2.__super__.constructor.call(this, parent);
          if (target == null) {
            throw new Error("Missing instruction target. " + this.debugInfo());
          }
          this.type = NodeType.ProcessingInstruction;
          this.target = this.stringify.insTarget(target);
          this.name = this.target;
          if (value) {
            this.value = this.stringify.insValue(value);
          }
        }
        XMLProcessingInstruction2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLProcessingInstruction2.prototype.toString = function(options) {
          return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(options));
        };
        XMLProcessingInstruction2.prototype.isEqualNode = function(node) {
          if (!XMLProcessingInstruction2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
            return false;
          }
          if (node.target !== this.target) {
            return false;
          }
          return true;
        };
        return XMLProcessingInstruction2;
      }(XMLCharacterData);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDummy.js
var require_XMLDummy = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDummy.js"(exports, module2) {
    (function() {
      var NodeType, XMLDummy, XMLNode, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module2.exports = XMLDummy = function(superClass) {
        extend(XMLDummy2, superClass);
        function XMLDummy2(parent) {
          XMLDummy2.__super__.constructor.call(this, parent);
          this.type = NodeType.Dummy;
        }
        XMLDummy2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLDummy2.prototype.toString = function(options) {
          return "";
        };
        return XMLDummy2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLNodeList.js
var require_XMLNodeList = __commonJS({
  "node_modules/xmlbuilder/lib/XMLNodeList.js"(exports, module2) {
    (function() {
      var XMLNodeList;
      module2.exports = XMLNodeList = function() {
        function XMLNodeList2(nodes) {
          this.nodes = nodes;
        }
        Object.defineProperty(XMLNodeList2.prototype, "length", {
          get: function() {
            return this.nodes.length || 0;
          }
        });
        XMLNodeList2.prototype.clone = function() {
          return this.nodes = null;
        };
        XMLNodeList2.prototype.item = function(index) {
          return this.nodes[index] || null;
        };
        return XMLNodeList2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/DocumentPosition.js
var require_DocumentPosition = __commonJS({
  "node_modules/xmlbuilder/lib/DocumentPosition.js"(exports, module2) {
    (function() {
      module2.exports = {
        Disconnected: 1,
        Preceding: 2,
        Following: 4,
        Contains: 8,
        ContainedBy: 16,
        ImplementationSpecific: 32
      };
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLNode.js
var require_XMLNode = __commonJS({
  "node_modules/xmlbuilder/lib/XMLNode.js"(exports, module2) {
    (function() {
      var DocumentPosition, NodeType, XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLNamedNodeMap, XMLNode, XMLNodeList, XMLProcessingInstruction, XMLRaw, XMLText, getValue, isEmpty, isFunction, isObject, ref1, hasProp = {}.hasOwnProperty;
      ref1 = require_Utility(), isObject = ref1.isObject, isFunction = ref1.isFunction, isEmpty = ref1.isEmpty, getValue = ref1.getValue;
      XMLElement = null;
      XMLCData = null;
      XMLComment = null;
      XMLDeclaration = null;
      XMLDocType = null;
      XMLRaw = null;
      XMLText = null;
      XMLProcessingInstruction = null;
      XMLDummy = null;
      NodeType = null;
      XMLNodeList = null;
      XMLNamedNodeMap = null;
      DocumentPosition = null;
      module2.exports = XMLNode = function() {
        function XMLNode2(parent1) {
          this.parent = parent1;
          if (this.parent) {
            this.options = this.parent.options;
            this.stringify = this.parent.stringify;
          }
          this.value = null;
          this.children = [];
          this.baseURI = null;
          if (!XMLElement) {
            XMLElement = require_XMLElement();
            XMLCData = require_XMLCData();
            XMLComment = require_XMLComment();
            XMLDeclaration = require_XMLDeclaration();
            XMLDocType = require_XMLDocType();
            XMLRaw = require_XMLRaw();
            XMLText = require_XMLText();
            XMLProcessingInstruction = require_XMLProcessingInstruction();
            XMLDummy = require_XMLDummy();
            NodeType = require_NodeType();
            XMLNodeList = require_XMLNodeList();
            XMLNamedNodeMap = require_XMLNamedNodeMap();
            DocumentPosition = require_DocumentPosition();
          }
        }
        Object.defineProperty(XMLNode2.prototype, "nodeName", {
          get: function() {
            return this.name;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "nodeType", {
          get: function() {
            return this.type;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "nodeValue", {
          get: function() {
            return this.value;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "parentNode", {
          get: function() {
            return this.parent;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "childNodes", {
          get: function() {
            if (!this.childNodeList || !this.childNodeList.nodes) {
              this.childNodeList = new XMLNodeList(this.children);
            }
            return this.childNodeList;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "firstChild", {
          get: function() {
            return this.children[0] || null;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "lastChild", {
          get: function() {
            return this.children[this.children.length - 1] || null;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "previousSibling", {
          get: function() {
            var i;
            i = this.parent.children.indexOf(this);
            return this.parent.children[i - 1] || null;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "nextSibling", {
          get: function() {
            var i;
            i = this.parent.children.indexOf(this);
            return this.parent.children[i + 1] || null;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "ownerDocument", {
          get: function() {
            return this.document() || null;
          }
        });
        Object.defineProperty(XMLNode2.prototype, "textContent", {
          get: function() {
            var child, j, len, ref2, str;
            if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {
              str = "";
              ref2 = this.children;
              for (j = 0, len = ref2.length; j < len; j++) {
                child = ref2[j];
                if (child.textContent) {
                  str += child.textContent;
                }
              }
              return str;
            } else {
              return null;
            }
          },
          set: function(value) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }
        });
        XMLNode2.prototype.setParent = function(parent) {
          var child, j, len, ref2, results;
          this.parent = parent;
          if (parent) {
            this.options = parent.options;
            this.stringify = parent.stringify;
          }
          ref2 = this.children;
          results = [];
          for (j = 0, len = ref2.length; j < len; j++) {
            child = ref2[j];
            results.push(child.setParent(this));
          }
          return results;
        };
        XMLNode2.prototype.element = function(name, attributes, text) {
          var childNode, item, j, k, key, lastChild, len, len1, ref2, ref3, val;
          lastChild = null;
          if (attributes === null && text == null) {
            ref2 = [{}, null], attributes = ref2[0], text = ref2[1];
          }
          if (attributes == null) {
            attributes = {};
          }
          attributes = getValue(attributes);
          if (!isObject(attributes)) {
            ref3 = [attributes, text], text = ref3[0], attributes = ref3[1];
          }
          if (name != null) {
            name = getValue(name);
          }
          if (Array.isArray(name)) {
            for (j = 0, len = name.length; j < len; j++) {
              item = name[j];
              lastChild = this.element(item);
            }
          } else if (isFunction(name)) {
            lastChild = this.element(name.apply());
          } else if (isObject(name)) {
            for (key in name) {
              if (!hasProp.call(name, key))
                continue;
              val = name[key];
              if (isFunction(val)) {
                val = val.apply();
              }
              if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
                lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
              } else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) {
                lastChild = this.dummy();
              } else if (isObject(val) && isEmpty(val)) {
                lastChild = this.element(key);
              } else if (!this.options.keepNullNodes && val == null) {
                lastChild = this.dummy();
              } else if (!this.options.separateArrayItems && Array.isArray(val)) {
                for (k = 0, len1 = val.length; k < len1; k++) {
                  item = val[k];
                  childNode = {};
                  childNode[key] = item;
                  lastChild = this.element(childNode);
                }
              } else if (isObject(val)) {
                if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0) {
                  lastChild = this.element(val);
                } else {
                  lastChild = this.element(key);
                  lastChild.element(val);
                }
              } else {
                lastChild = this.element(key, val);
              }
            }
          } else if (!this.options.keepNullNodes && text === null) {
            lastChild = this.dummy();
          } else {
            if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
              lastChild = this.text(text);
            } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
              lastChild = this.cdata(text);
            } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
              lastChild = this.comment(text);
            } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
              lastChild = this.raw(text);
            } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {
              lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);
            } else {
              lastChild = this.node(name, attributes, text);
            }
          }
          if (lastChild == null) {
            throw new Error("Could not create any elements with: " + name + ". " + this.debugInfo());
          }
          return lastChild;
        };
        XMLNode2.prototype.insertBefore = function(name, attributes, text) {
          var child, i, newChild, refChild, removed;
          if (name != null ? name.type : void 0) {
            newChild = name;
            refChild = attributes;
            newChild.setParent(this);
            if (refChild) {
              i = children.indexOf(refChild);
              removed = children.splice(i);
              children.push(newChild);
              Array.prototype.push.apply(children, removed);
            } else {
              children.push(newChild);
            }
            return newChild;
          } else {
            if (this.isRoot) {
              throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
            }
            i = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i);
            child = this.parent.element(name, attributes, text);
            Array.prototype.push.apply(this.parent.children, removed);
            return child;
          }
        };
        XMLNode2.prototype.insertAfter = function(name, attributes, text) {
          var child, i, removed;
          if (this.isRoot) {
            throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
          }
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i + 1);
          child = this.parent.element(name, attributes, text);
          Array.prototype.push.apply(this.parent.children, removed);
          return child;
        };
        XMLNode2.prototype.remove = function() {
          var i, ref2;
          if (this.isRoot) {
            throw new Error("Cannot remove the root element. " + this.debugInfo());
          }
          i = this.parent.children.indexOf(this);
          [].splice.apply(this.parent.children, [i, i - i + 1].concat(ref2 = [])), ref2;
          return this.parent;
        };
        XMLNode2.prototype.node = function(name, attributes, text) {
          var child, ref2;
          if (name != null) {
            name = getValue(name);
          }
          attributes || (attributes = {});
          attributes = getValue(attributes);
          if (!isObject(attributes)) {
            ref2 = [attributes, text], text = ref2[0], attributes = ref2[1];
          }
          child = new XMLElement(this, name, attributes);
          if (text != null) {
            child.text(text);
          }
          this.children.push(child);
          return child;
        };
        XMLNode2.prototype.text = function(value) {
          var child;
          if (isObject(value)) {
            this.element(value);
          }
          child = new XMLText(this, value);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.cdata = function(value) {
          var child;
          child = new XMLCData(this, value);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.comment = function(value) {
          var child;
          child = new XMLComment(this, value);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.commentBefore = function(value) {
          var child, i, removed;
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i);
          child = this.parent.comment(value);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.commentAfter = function(value) {
          var child, i, removed;
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i + 1);
          child = this.parent.comment(value);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.raw = function(value) {
          var child;
          child = new XMLRaw(this, value);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.dummy = function() {
          var child;
          child = new XMLDummy(this);
          return child;
        };
        XMLNode2.prototype.instruction = function(target, value) {
          var insTarget, insValue, instruction, j, len;
          if (target != null) {
            target = getValue(target);
          }
          if (value != null) {
            value = getValue(value);
          }
          if (Array.isArray(target)) {
            for (j = 0, len = target.length; j < len; j++) {
              insTarget = target[j];
              this.instruction(insTarget);
            }
          } else if (isObject(target)) {
            for (insTarget in target) {
              if (!hasProp.call(target, insTarget))
                continue;
              insValue = target[insTarget];
              this.instruction(insTarget, insValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            instruction = new XMLProcessingInstruction(this, target, value);
            this.children.push(instruction);
          }
          return this;
        };
        XMLNode2.prototype.instructionBefore = function(target, value) {
          var child, i, removed;
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i);
          child = this.parent.instruction(target, value);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.instructionAfter = function(target, value) {
          var child, i, removed;
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i + 1);
          child = this.parent.instruction(target, value);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.declaration = function(version, encoding, standalone) {
          var doc, xmldec;
          doc = this.document();
          xmldec = new XMLDeclaration(doc, version, encoding, standalone);
          if (doc.children.length === 0) {
            doc.children.unshift(xmldec);
          } else if (doc.children[0].type === NodeType.Declaration) {
            doc.children[0] = xmldec;
          } else {
            doc.children.unshift(xmldec);
          }
          return doc.root() || doc;
        };
        XMLNode2.prototype.dtd = function(pubID, sysID) {
          var child, doc, doctype, i, j, k, len, len1, ref2, ref3;
          doc = this.document();
          doctype = new XMLDocType(doc, pubID, sysID);
          ref2 = doc.children;
          for (i = j = 0, len = ref2.length; j < len; i = ++j) {
            child = ref2[i];
            if (child.type === NodeType.DocType) {
              doc.children[i] = doctype;
              return doctype;
            }
          }
          ref3 = doc.children;
          for (i = k = 0, len1 = ref3.length; k < len1; i = ++k) {
            child = ref3[i];
            if (child.isRoot) {
              doc.children.splice(i, 0, doctype);
              return doctype;
            }
          }
          doc.children.push(doctype);
          return doctype;
        };
        XMLNode2.prototype.up = function() {
          if (this.isRoot) {
            throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
          }
          return this.parent;
        };
        XMLNode2.prototype.root = function() {
          var node;
          node = this;
          while (node) {
            if (node.type === NodeType.Document) {
              return node.rootObject;
            } else if (node.isRoot) {
              return node;
            } else {
              node = node.parent;
            }
          }
        };
        XMLNode2.prototype.document = function() {
          var node;
          node = this;
          while (node) {
            if (node.type === NodeType.Document) {
              return node;
            } else {
              node = node.parent;
            }
          }
        };
        XMLNode2.prototype.end = function(options) {
          return this.document().end(options);
        };
        XMLNode2.prototype.prev = function() {
          var i;
          i = this.parent.children.indexOf(this);
          if (i < 1) {
            throw new Error("Already at the first node. " + this.debugInfo());
          }
          return this.parent.children[i - 1];
        };
        XMLNode2.prototype.next = function() {
          var i;
          i = this.parent.children.indexOf(this);
          if (i === -1 || i === this.parent.children.length - 1) {
            throw new Error("Already at the last node. " + this.debugInfo());
          }
          return this.parent.children[i + 1];
        };
        XMLNode2.prototype.importDocument = function(doc) {
          var clonedRoot;
          clonedRoot = doc.root().clone();
          clonedRoot.parent = this;
          clonedRoot.isRoot = false;
          this.children.push(clonedRoot);
          return this;
        };
        XMLNode2.prototype.debugInfo = function(name) {
          var ref2, ref3;
          name = name || this.name;
          if (name == null && !((ref2 = this.parent) != null ? ref2.name : void 0)) {
            return "";
          } else if (name == null) {
            return "parent: <" + this.parent.name + ">";
          } else if (!((ref3 = this.parent) != null ? ref3.name : void 0)) {
            return "node: <" + name + ">";
          } else {
            return "node: <" + name + ">, parent: <" + this.parent.name + ">";
          }
        };
        XMLNode2.prototype.ele = function(name, attributes, text) {
          return this.element(name, attributes, text);
        };
        XMLNode2.prototype.nod = function(name, attributes, text) {
          return this.node(name, attributes, text);
        };
        XMLNode2.prototype.txt = function(value) {
          return this.text(value);
        };
        XMLNode2.prototype.dat = function(value) {
          return this.cdata(value);
        };
        XMLNode2.prototype.com = function(value) {
          return this.comment(value);
        };
        XMLNode2.prototype.ins = function(target, value) {
          return this.instruction(target, value);
        };
        XMLNode2.prototype.doc = function() {
          return this.document();
        };
        XMLNode2.prototype.dec = function(version, encoding, standalone) {
          return this.declaration(version, encoding, standalone);
        };
        XMLNode2.prototype.e = function(name, attributes, text) {
          return this.element(name, attributes, text);
        };
        XMLNode2.prototype.n = function(name, attributes, text) {
          return this.node(name, attributes, text);
        };
        XMLNode2.prototype.t = function(value) {
          return this.text(value);
        };
        XMLNode2.prototype.d = function(value) {
          return this.cdata(value);
        };
        XMLNode2.prototype.c = function(value) {
          return this.comment(value);
        };
        XMLNode2.prototype.r = function(value) {
          return this.raw(value);
        };
        XMLNode2.prototype.i = function(target, value) {
          return this.instruction(target, value);
        };
        XMLNode2.prototype.u = function() {
          return this.up();
        };
        XMLNode2.prototype.importXMLBuilder = function(doc) {
          return this.importDocument(doc);
        };
        XMLNode2.prototype.replaceChild = function(newChild, oldChild) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.removeChild = function(oldChild) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.appendChild = function(newChild) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.hasChildNodes = function() {
          return this.children.length !== 0;
        };
        XMLNode2.prototype.cloneNode = function(deep) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.normalize = function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.isSupported = function(feature, version) {
          return true;
        };
        XMLNode2.prototype.hasAttributes = function() {
          return this.attribs.length !== 0;
        };
        XMLNode2.prototype.compareDocumentPosition = function(other) {
          var ref, res;
          ref = this;
          if (ref === other) {
            return 0;
          } else if (this.document() !== other.document()) {
            res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;
            if (Math.random() < 0.5) {
              res |= DocumentPosition.Preceding;
            } else {
              res |= DocumentPosition.Following;
            }
            return res;
          } else if (ref.isAncestor(other)) {
            return DocumentPosition.Contains | DocumentPosition.Preceding;
          } else if (ref.isDescendant(other)) {
            return DocumentPosition.Contains | DocumentPosition.Following;
          } else if (ref.isPreceding(other)) {
            return DocumentPosition.Preceding;
          } else {
            return DocumentPosition.Following;
          }
        };
        XMLNode2.prototype.isSameNode = function(other) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.lookupPrefix = function(namespaceURI) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.isDefaultNamespace = function(namespaceURI) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.lookupNamespaceURI = function(prefix) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.isEqualNode = function(node) {
          var i, j, ref2;
          if (node.nodeType !== this.nodeType) {
            return false;
          }
          if (node.children.length !== this.children.length) {
            return false;
          }
          for (i = j = 0, ref2 = this.children.length - 1; 0 <= ref2 ? j <= ref2 : j >= ref2; i = 0 <= ref2 ? ++j : --j) {
            if (!this.children[i].isEqualNode(node.children[i])) {
              return false;
            }
          }
          return true;
        };
        XMLNode2.prototype.getFeature = function(feature, version) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.setUserData = function(key, data, handler) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.getUserData = function(key) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.contains = function(other) {
          if (!other) {
            return false;
          }
          return other === this || this.isDescendant(other);
        };
        XMLNode2.prototype.isDescendant = function(node) {
          var child, isDescendantChild, j, len, ref2;
          ref2 = this.children;
          for (j = 0, len = ref2.length; j < len; j++) {
            child = ref2[j];
            if (node === child) {
              return true;
            }
            isDescendantChild = child.isDescendant(node);
            if (isDescendantChild) {
              return true;
            }
          }
          return false;
        };
        XMLNode2.prototype.isAncestor = function(node) {
          return node.isDescendant(this);
        };
        XMLNode2.prototype.isPreceding = function(node) {
          var nodePos, thisPos;
          nodePos = this.treePosition(node);
          thisPos = this.treePosition(this);
          if (nodePos === -1 || thisPos === -1) {
            return false;
          } else {
            return nodePos < thisPos;
          }
        };
        XMLNode2.prototype.isFollowing = function(node) {
          var nodePos, thisPos;
          nodePos = this.treePosition(node);
          thisPos = this.treePosition(this);
          if (nodePos === -1 || thisPos === -1) {
            return false;
          } else {
            return nodePos > thisPos;
          }
        };
        XMLNode2.prototype.treePosition = function(node) {
          var found, pos;
          pos = 0;
          found = false;
          this.foreachTreeNode(this.document(), function(childNode) {
            pos++;
            if (!found && childNode === node) {
              return found = true;
            }
          });
          if (found) {
            return pos;
          } else {
            return -1;
          }
        };
        XMLNode2.prototype.foreachTreeNode = function(node, func) {
          var child, j, len, ref2, res;
          node || (node = this.document());
          ref2 = node.children;
          for (j = 0, len = ref2.length; j < len; j++) {
            child = ref2[j];
            if (res = func(child)) {
              return res;
            } else {
              res = this.foreachTreeNode(child, func);
              if (res) {
                return res;
              }
            }
          }
        };
        return XMLNode2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLStringifier.js
var require_XMLStringifier = __commonJS({
  "node_modules/xmlbuilder/lib/XMLStringifier.js"(exports, module2) {
    (function() {
      var XMLStringifier, bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      }, hasProp = {}.hasOwnProperty;
      module2.exports = XMLStringifier = function() {
        function XMLStringifier2(options) {
          this.assertLegalName = bind(this.assertLegalName, this);
          this.assertLegalChar = bind(this.assertLegalChar, this);
          var key, ref, value;
          options || (options = {});
          this.options = options;
          if (!this.options.version) {
            this.options.version = "1.0";
          }
          ref = options.stringify || {};
          for (key in ref) {
            if (!hasProp.call(ref, key))
              continue;
            value = ref[key];
            this[key] = value;
          }
        }
        XMLStringifier2.prototype.name = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalName("" + val || "");
        };
        XMLStringifier2.prototype.text = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar(this.textEscape("" + val || ""));
        };
        XMLStringifier2.prototype.cdata = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          val = "" + val || "";
          val = val.replace("]]>", "]]]]><![CDATA[>");
          return this.assertLegalChar(val);
        };
        XMLStringifier2.prototype.comment = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          val = "" + val || "";
          if (val.match(/--/)) {
            throw new Error("Comment text cannot contain double-hypen: " + val);
          }
          return this.assertLegalChar(val);
        };
        XMLStringifier2.prototype.raw = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return "" + val || "";
        };
        XMLStringifier2.prototype.attValue = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar(this.attEscape(val = "" + val || ""));
        };
        XMLStringifier2.prototype.insTarget = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.insValue = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          val = "" + val || "";
          if (val.match(/\?>/)) {
            throw new Error("Invalid processing instruction value: " + val);
          }
          return this.assertLegalChar(val);
        };
        XMLStringifier2.prototype.xmlVersion = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          val = "" + val || "";
          if (!val.match(/1\.[0-9]+/)) {
            throw new Error("Invalid version number: " + val);
          }
          return val;
        };
        XMLStringifier2.prototype.xmlEncoding = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          val = "" + val || "";
          if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
            throw new Error("Invalid encoding: " + val);
          }
          return this.assertLegalChar(val);
        };
        XMLStringifier2.prototype.xmlStandalone = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          if (val) {
            return "yes";
          } else {
            return "no";
          }
        };
        XMLStringifier2.prototype.dtdPubID = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.dtdSysID = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.dtdElementValue = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.dtdAttType = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.dtdAttDefault = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.dtdEntityValue = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.dtdNData = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.convertAttKey = "@";
        XMLStringifier2.prototype.convertPIKey = "?";
        XMLStringifier2.prototype.convertTextKey = "#text";
        XMLStringifier2.prototype.convertCDataKey = "#cdata";
        XMLStringifier2.prototype.convertCommentKey = "#comment";
        XMLStringifier2.prototype.convertRawKey = "#raw";
        XMLStringifier2.prototype.assertLegalChar = function(str) {
          var regex, res;
          if (this.options.noValidation) {
            return str;
          }
          regex = "";
          if (this.options.version === "1.0") {
            regex = /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
            if (res = str.match(regex)) {
              throw new Error("Invalid character in string: " + str + " at index " + res.index);
            }
          } else if (this.options.version === "1.1") {
            regex = /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
            if (res = str.match(regex)) {
              throw new Error("Invalid character in string: " + str + " at index " + res.index);
            }
          }
          return str;
        };
        XMLStringifier2.prototype.assertLegalName = function(str) {
          var regex;
          if (this.options.noValidation) {
            return str;
          }
          this.assertLegalChar(str);
          regex = /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/;
          if (!str.match(regex)) {
            throw new Error("Invalid character in name");
          }
          return str;
        };
        XMLStringifier2.prototype.textEscape = function(str) {
          var ampregex;
          if (this.options.noValidation) {
            return str;
          }
          ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
          return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;");
        };
        XMLStringifier2.prototype.attEscape = function(str) {
          var ampregex;
          if (this.options.noValidation) {
            return str;
          }
          ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
          return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
        };
        return XMLStringifier2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/WriterState.js
var require_WriterState = __commonJS({
  "node_modules/xmlbuilder/lib/WriterState.js"(exports, module2) {
    (function() {
      module2.exports = {
        None: 0,
        OpenTag: 1,
        InsideTag: 2,
        CloseTag: 3
      };
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLWriterBase.js
var require_XMLWriterBase = __commonJS({
  "node_modules/xmlbuilder/lib/XMLWriterBase.js"(exports, module2) {
    (function() {
      var NodeType, WriterState, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLProcessingInstruction, XMLRaw, XMLText, XMLWriterBase, assign, hasProp = {}.hasOwnProperty;
      assign = require_Utility().assign;
      NodeType = require_NodeType();
      XMLDeclaration = require_XMLDeclaration();
      XMLDocType = require_XMLDocType();
      XMLCData = require_XMLCData();
      XMLComment = require_XMLComment();
      XMLElement = require_XMLElement();
      XMLRaw = require_XMLRaw();
      XMLText = require_XMLText();
      XMLProcessingInstruction = require_XMLProcessingInstruction();
      XMLDummy = require_XMLDummy();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDNotation = require_XMLDTDNotation();
      WriterState = require_WriterState();
      module2.exports = XMLWriterBase = function() {
        function XMLWriterBase2(options) {
          var key, ref, value;
          options || (options = {});
          this.options = options;
          ref = options.writer || {};
          for (key in ref) {
            if (!hasProp.call(ref, key))
              continue;
            value = ref[key];
            this["_" + key] = this[key];
            this[key] = value;
          }
        }
        XMLWriterBase2.prototype.filterOptions = function(options) {
          var filteredOptions, ref, ref1, ref2, ref3, ref4, ref5, ref6;
          options || (options = {});
          options = assign({}, this.options, options);
          filteredOptions = {
            writer: this
          };
          filteredOptions.pretty = options.pretty || false;
          filteredOptions.allowEmpty = options.allowEmpty || false;
          filteredOptions.indent = (ref = options.indent) != null ? ref : "  ";
          filteredOptions.newline = (ref1 = options.newline) != null ? ref1 : "\n";
          filteredOptions.offset = (ref2 = options.offset) != null ? ref2 : 0;
          filteredOptions.dontPrettyTextNodes = (ref3 = (ref4 = options.dontPrettyTextNodes) != null ? ref4 : options.dontprettytextnodes) != null ? ref3 : 0;
          filteredOptions.spaceBeforeSlash = (ref5 = (ref6 = options.spaceBeforeSlash) != null ? ref6 : options.spacebeforeslash) != null ? ref5 : "";
          if (filteredOptions.spaceBeforeSlash === true) {
            filteredOptions.spaceBeforeSlash = " ";
          }
          filteredOptions.suppressPrettyCount = 0;
          filteredOptions.user = {};
          filteredOptions.state = WriterState.None;
          return filteredOptions;
        };
        XMLWriterBase2.prototype.indent = function(node, options, level) {
          var indentLevel;
          if (!options.pretty || options.suppressPrettyCount) {
            return "";
          } else if (options.pretty) {
            indentLevel = (level || 0) + options.offset + 1;
            if (indentLevel > 0) {
              return new Array(indentLevel).join(options.indent);
            }
          }
          return "";
        };
        XMLWriterBase2.prototype.endline = function(node, options, level) {
          if (!options.pretty || options.suppressPrettyCount) {
            return "";
          } else {
            return options.newline;
          }
        };
        XMLWriterBase2.prototype.attribute = function(att, options, level) {
          var r;
          this.openAttribute(att, options, level);
          r = " " + att.name + '="' + att.value + '"';
          this.closeAttribute(att, options, level);
          return r;
        };
        XMLWriterBase2.prototype.cdata = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<![CDATA[";
          options.state = WriterState.InsideTag;
          r += node.value;
          options.state = WriterState.CloseTag;
          r += "]]>" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.comment = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<!-- ";
          options.state = WriterState.InsideTag;
          r += node.value;
          options.state = WriterState.CloseTag;
          r += " -->" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.declaration = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<?xml";
          options.state = WriterState.InsideTag;
          r += ' version="' + node.version + '"';
          if (node.encoding != null) {
            r += ' encoding="' + node.encoding + '"';
          }
          if (node.standalone != null) {
            r += ' standalone="' + node.standalone + '"';
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + "?>";
          r += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.docType = function(node, options, level) {
          var child, i, len, r, ref;
          level || (level = 0);
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level);
          r += "<!DOCTYPE " + node.root().name;
          if (node.pubID && node.sysID) {
            r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
          } else if (node.sysID) {
            r += ' SYSTEM "' + node.sysID + '"';
          }
          if (node.children.length > 0) {
            r += " [";
            r += this.endline(node, options, level);
            options.state = WriterState.InsideTag;
            ref = node.children;
            for (i = 0, len = ref.length; i < len; i++) {
              child = ref[i];
              r += this.writeChildNode(child, options, level + 1);
            }
            options.state = WriterState.CloseTag;
            r += "]";
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + ">";
          r += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.element = function(node, options, level) {
          var att, child, childNodeCount, firstChildNode, i, j, len, len1, name, prettySuppressed, r, ref, ref1, ref2;
          level || (level = 0);
          prettySuppressed = false;
          r = "";
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r += this.indent(node, options, level) + "<" + node.name;
          ref = node.attribs;
          for (name in ref) {
            if (!hasProp.call(ref, name))
              continue;
            att = ref[name];
            r += this.attribute(att, options, level);
          }
          childNodeCount = node.children.length;
          firstChildNode = childNodeCount === 0 ? null : node.children[0];
          if (childNodeCount === 0 || node.children.every(function(e) {
            return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === "";
          })) {
            if (options.allowEmpty) {
              r += ">";
              options.state = WriterState.CloseTag;
              r += "</" + node.name + ">" + this.endline(node, options, level);
            } else {
              options.state = WriterState.CloseTag;
              r += options.spaceBeforeSlash + "/>" + this.endline(node, options, level);
            }
          } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null) {
            r += ">";
            options.state = WriterState.InsideTag;
            options.suppressPrettyCount++;
            prettySuppressed = true;
            r += this.writeChildNode(firstChildNode, options, level + 1);
            options.suppressPrettyCount--;
            prettySuppressed = false;
            options.state = WriterState.CloseTag;
            r += "</" + node.name + ">" + this.endline(node, options, level);
          } else {
            if (options.dontPrettyTextNodes) {
              ref1 = node.children;
              for (i = 0, len = ref1.length; i < len; i++) {
                child = ref1[i];
                if ((child.type === NodeType.Text || child.type === NodeType.Raw) && child.value != null) {
                  options.suppressPrettyCount++;
                  prettySuppressed = true;
                  break;
                }
              }
            }
            r += ">" + this.endline(node, options, level);
            options.state = WriterState.InsideTag;
            ref2 = node.children;
            for (j = 0, len1 = ref2.length; j < len1; j++) {
              child = ref2[j];
              r += this.writeChildNode(child, options, level + 1);
            }
            options.state = WriterState.CloseTag;
            r += this.indent(node, options, level) + "</" + node.name + ">";
            if (prettySuppressed) {
              options.suppressPrettyCount--;
            }
            r += this.endline(node, options, level);
            options.state = WriterState.None;
          }
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.writeChildNode = function(node, options, level) {
          switch (node.type) {
            case NodeType.CData:
              return this.cdata(node, options, level);
            case NodeType.Comment:
              return this.comment(node, options, level);
            case NodeType.Element:
              return this.element(node, options, level);
            case NodeType.Raw:
              return this.raw(node, options, level);
            case NodeType.Text:
              return this.text(node, options, level);
            case NodeType.ProcessingInstruction:
              return this.processingInstruction(node, options, level);
            case NodeType.Dummy:
              return "";
            case NodeType.Declaration:
              return this.declaration(node, options, level);
            case NodeType.DocType:
              return this.docType(node, options, level);
            case NodeType.AttributeDeclaration:
              return this.dtdAttList(node, options, level);
            case NodeType.ElementDeclaration:
              return this.dtdElement(node, options, level);
            case NodeType.EntityDeclaration:
              return this.dtdEntity(node, options, level);
            case NodeType.NotationDeclaration:
              return this.dtdNotation(node, options, level);
            default:
              throw new Error("Unknown XML node type: " + node.constructor.name);
          }
        };
        XMLWriterBase2.prototype.processingInstruction = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<?";
          options.state = WriterState.InsideTag;
          r += node.target;
          if (node.value) {
            r += " " + node.value;
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + "?>";
          r += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.raw = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level);
          options.state = WriterState.InsideTag;
          r += node.value;
          options.state = WriterState.CloseTag;
          r += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.text = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level);
          options.state = WriterState.InsideTag;
          r += node.value;
          options.state = WriterState.CloseTag;
          r += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.dtdAttList = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<!ATTLIST";
          options.state = WriterState.InsideTag;
          r += " " + node.elementName + " " + node.attributeName + " " + node.attributeType;
          if (node.defaultValueType !== "#DEFAULT") {
            r += " " + node.defaultValueType;
          }
          if (node.defaultValue) {
            r += ' "' + node.defaultValue + '"';
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.dtdElement = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<!ELEMENT";
          options.state = WriterState.InsideTag;
          r += " " + node.name + " " + node.value;
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.dtdEntity = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<!ENTITY";
          options.state = WriterState.InsideTag;
          if (node.pe) {
            r += " %";
          }
          r += " " + node.name;
          if (node.value) {
            r += ' "' + node.value + '"';
          } else {
            if (node.pubID && node.sysID) {
              r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
            } else if (node.sysID) {
              r += ' SYSTEM "' + node.sysID + '"';
            }
            if (node.nData) {
              r += " NDATA " + node.nData;
            }
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.dtdNotation = function(node, options, level) {
          var r;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r = this.indent(node, options, level) + "<!NOTATION";
          options.state = WriterState.InsideTag;
          r += " " + node.name;
          if (node.pubID && node.sysID) {
            r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
          } else if (node.pubID) {
            r += ' PUBLIC "' + node.pubID + '"';
          } else if (node.sysID) {
            r += ' SYSTEM "' + node.sysID + '"';
          }
          options.state = WriterState.CloseTag;
          r += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r;
        };
        XMLWriterBase2.prototype.openNode = function(node, options, level) {
        };
        XMLWriterBase2.prototype.closeNode = function(node, options, level) {
        };
        XMLWriterBase2.prototype.openAttribute = function(att, options, level) {
        };
        XMLWriterBase2.prototype.closeAttribute = function(att, options, level) {
        };
        return XMLWriterBase2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLStringWriter.js
var require_XMLStringWriter = __commonJS({
  "node_modules/xmlbuilder/lib/XMLStringWriter.js"(exports, module2) {
    (function() {
      var XMLStringWriter, XMLWriterBase, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLWriterBase = require_XMLWriterBase();
      module2.exports = XMLStringWriter = function(superClass) {
        extend(XMLStringWriter2, superClass);
        function XMLStringWriter2(options) {
          XMLStringWriter2.__super__.constructor.call(this, options);
        }
        XMLStringWriter2.prototype.document = function(doc, options) {
          var child, i, len, r, ref;
          options = this.filterOptions(options);
          r = "";
          ref = doc.children;
          for (i = 0, len = ref.length; i < len; i++) {
            child = ref[i];
            r += this.writeChildNode(child, options, 0);
          }
          if (options.pretty && r.slice(-options.newline.length) === options.newline) {
            r = r.slice(0, -options.newline.length);
          }
          return r;
        };
        return XMLStringWriter2;
      }(XMLWriterBase);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDocument.js
var require_XMLDocument = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDocument.js"(exports, module2) {
    (function() {
      var NodeType, XMLDOMConfiguration, XMLDOMImplementation, XMLDocument, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      isPlainObject = require_Utility().isPlainObject;
      XMLDOMImplementation = require_XMLDOMImplementation();
      XMLDOMConfiguration = require_XMLDOMConfiguration();
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      XMLStringifier = require_XMLStringifier();
      XMLStringWriter = require_XMLStringWriter();
      module2.exports = XMLDocument = function(superClass) {
        extend(XMLDocument2, superClass);
        function XMLDocument2(options) {
          XMLDocument2.__super__.constructor.call(this, null);
          this.name = "#document";
          this.type = NodeType.Document;
          this.documentURI = null;
          this.domConfig = new XMLDOMConfiguration();
          options || (options = {});
          if (!options.writer) {
            options.writer = new XMLStringWriter();
          }
          this.options = options;
          this.stringify = new XMLStringifier(options);
        }
        Object.defineProperty(XMLDocument2.prototype, "implementation", {
          value: new XMLDOMImplementation()
        });
        Object.defineProperty(XMLDocument2.prototype, "doctype", {
          get: function() {
            var child, i, len, ref;
            ref = this.children;
            for (i = 0, len = ref.length; i < len; i++) {
              child = ref[i];
              if (child.type === NodeType.DocType) {
                return child;
              }
            }
            return null;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "documentElement", {
          get: function() {
            return this.rootObject || null;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "inputEncoding", {
          get: function() {
            return null;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "strictErrorChecking", {
          get: function() {
            return false;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "xmlEncoding", {
          get: function() {
            if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
              return this.children[0].encoding;
            } else {
              return null;
            }
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "xmlStandalone", {
          get: function() {
            if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
              return this.children[0].standalone === "yes";
            } else {
              return false;
            }
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "xmlVersion", {
          get: function() {
            if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
              return this.children[0].version;
            } else {
              return "1.0";
            }
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "URL", {
          get: function() {
            return this.documentURI;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "origin", {
          get: function() {
            return null;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "compatMode", {
          get: function() {
            return null;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "characterSet", {
          get: function() {
            return null;
          }
        });
        Object.defineProperty(XMLDocument2.prototype, "contentType", {
          get: function() {
            return null;
          }
        });
        XMLDocument2.prototype.end = function(writer) {
          var writerOptions;
          writerOptions = {};
          if (!writer) {
            writer = this.options.writer;
          } else if (isPlainObject(writer)) {
            writerOptions = writer;
            writer = this.options.writer;
          }
          return writer.document(this, writer.filterOptions(writerOptions));
        };
        XMLDocument2.prototype.toString = function(options) {
          return this.options.writer.document(this, this.options.writer.filterOptions(options));
        };
        XMLDocument2.prototype.createElement = function(tagName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createDocumentFragment = function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createTextNode = function(data) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createComment = function(data) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createCDATASection = function(data) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createProcessingInstruction = function(target, data) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createAttribute = function(name) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createEntityReference = function(name) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.getElementsByTagName = function(tagname) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.importNode = function(importedNode, deep) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createElementNS = function(namespaceURI, qualifiedName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createAttributeNS = function(namespaceURI, qualifiedName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.getElementById = function(elementId) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.adoptNode = function(source) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.normalizeDocument = function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.renameNode = function(node, namespaceURI, qualifiedName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.getElementsByClassName = function(classNames) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createEvent = function(eventInterface) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createRange = function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createNodeIterator = function(root, whatToShow, filter) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createTreeWalker = function(root, whatToShow, filter) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        return XMLDocument2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDocumentCB.js
var require_XMLDocumentCB = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDocumentCB.js"(exports, module2) {
    (function() {
      var NodeType, WriterState, XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocument, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, getValue, isFunction, isObject, isPlainObject, ref, hasProp = {}.hasOwnProperty;
      ref = require_Utility(), isObject = ref.isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject, getValue = ref.getValue;
      NodeType = require_NodeType();
      XMLDocument = require_XMLDocument();
      XMLElement = require_XMLElement();
      XMLCData = require_XMLCData();
      XMLComment = require_XMLComment();
      XMLRaw = require_XMLRaw();
      XMLText = require_XMLText();
      XMLProcessingInstruction = require_XMLProcessingInstruction();
      XMLDeclaration = require_XMLDeclaration();
      XMLDocType = require_XMLDocType();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDNotation = require_XMLDTDNotation();
      XMLAttribute = require_XMLAttribute();
      XMLStringifier = require_XMLStringifier();
      XMLStringWriter = require_XMLStringWriter();
      WriterState = require_WriterState();
      module2.exports = XMLDocumentCB = function() {
        function XMLDocumentCB2(options, onData, onEnd) {
          var writerOptions;
          this.name = "?xml";
          this.type = NodeType.Document;
          options || (options = {});
          writerOptions = {};
          if (!options.writer) {
            options.writer = new XMLStringWriter();
          } else if (isPlainObject(options.writer)) {
            writerOptions = options.writer;
            options.writer = new XMLStringWriter();
          }
          this.options = options;
          this.writer = options.writer;
          this.writerOptions = this.writer.filterOptions(writerOptions);
          this.stringify = new XMLStringifier(options);
          this.onDataCallback = onData || function() {
          };
          this.onEndCallback = onEnd || function() {
          };
          this.currentNode = null;
          this.currentLevel = -1;
          this.openTags = {};
          this.documentStarted = false;
          this.documentCompleted = false;
          this.root = null;
        }
        XMLDocumentCB2.prototype.createChildNode = function(node) {
          var att, attName, attributes, child, i, len, ref1, ref2;
          switch (node.type) {
            case NodeType.CData:
              this.cdata(node.value);
              break;
            case NodeType.Comment:
              this.comment(node.value);
              break;
            case NodeType.Element:
              attributes = {};
              ref1 = node.attribs;
              for (attName in ref1) {
                if (!hasProp.call(ref1, attName))
                  continue;
                att = ref1[attName];
                attributes[attName] = att.value;
              }
              this.node(node.name, attributes);
              break;
            case NodeType.Dummy:
              this.dummy();
              break;
            case NodeType.Raw:
              this.raw(node.value);
              break;
            case NodeType.Text:
              this.text(node.value);
              break;
            case NodeType.ProcessingInstruction:
              this.instruction(node.target, node.value);
              break;
            default:
              throw new Error("This XML node type is not supported in a JS object: " + node.constructor.name);
          }
          ref2 = node.children;
          for (i = 0, len = ref2.length; i < len; i++) {
            child = ref2[i];
            this.createChildNode(child);
            if (child.type === NodeType.Element) {
              this.up();
            }
          }
          return this;
        };
        XMLDocumentCB2.prototype.dummy = function() {
          return this;
        };
        XMLDocumentCB2.prototype.node = function(name, attributes, text) {
          var ref1;
          if (name == null) {
            throw new Error("Missing node name.");
          }
          if (this.root && this.currentLevel === -1) {
            throw new Error("Document can only have one root node. " + this.debugInfo(name));
          }
          this.openCurrent();
          name = getValue(name);
          if (attributes == null) {
            attributes = {};
          }
          attributes = getValue(attributes);
          if (!isObject(attributes)) {
            ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
          }
          this.currentNode = new XMLElement(this, name, attributes);
          this.currentNode.children = false;
          this.currentLevel++;
          this.openTags[this.currentLevel] = this.currentNode;
          if (text != null) {
            this.text(text);
          }
          return this;
        };
        XMLDocumentCB2.prototype.element = function(name, attributes, text) {
          var child, i, len, oldValidationFlag, ref1, root;
          if (this.currentNode && this.currentNode.type === NodeType.DocType) {
            this.dtdElement.apply(this, arguments);
          } else {
            if (Array.isArray(name) || isObject(name) || isFunction(name)) {
              oldValidationFlag = this.options.noValidation;
              this.options.noValidation = true;
              root = new XMLDocument(this.options).element("TEMP_ROOT");
              root.element(name);
              this.options.noValidation = oldValidationFlag;
              ref1 = root.children;
              for (i = 0, len = ref1.length; i < len; i++) {
                child = ref1[i];
                this.createChildNode(child);
                if (child.type === NodeType.Element) {
                  this.up();
                }
              }
            } else {
              this.node(name, attributes, text);
            }
          }
          return this;
        };
        XMLDocumentCB2.prototype.attribute = function(name, value) {
          var attName, attValue;
          if (!this.currentNode || this.currentNode.children) {
            throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(name));
          }
          if (name != null) {
            name = getValue(name);
          }
          if (isObject(name)) {
            for (attName in name) {
              if (!hasProp.call(name, attName))
                continue;
              attValue = name[attName];
              this.attribute(attName, attValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            if (this.options.keepNullAttributes && value == null) {
              this.currentNode.attribs[name] = new XMLAttribute(this, name, "");
            } else if (value != null) {
              this.currentNode.attribs[name] = new XMLAttribute(this, name, value);
            }
          }
          return this;
        };
        XMLDocumentCB2.prototype.text = function(value) {
          var node;
          this.openCurrent();
          node = new XMLText(this, value);
          this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.cdata = function(value) {
          var node;
          this.openCurrent();
          node = new XMLCData(this, value);
          this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.comment = function(value) {
          var node;
          this.openCurrent();
          node = new XMLComment(this, value);
          this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.raw = function(value) {
          var node;
          this.openCurrent();
          node = new XMLRaw(this, value);
          this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.instruction = function(target, value) {
          var i, insTarget, insValue, len, node;
          this.openCurrent();
          if (target != null) {
            target = getValue(target);
          }
          if (value != null) {
            value = getValue(value);
          }
          if (Array.isArray(target)) {
            for (i = 0, len = target.length; i < len; i++) {
              insTarget = target[i];
              this.instruction(insTarget);
            }
          } else if (isObject(target)) {
            for (insTarget in target) {
              if (!hasProp.call(target, insTarget))
                continue;
              insValue = target[insTarget];
              this.instruction(insTarget, insValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            node = new XMLProcessingInstruction(this, target, value);
            this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          }
          return this;
        };
        XMLDocumentCB2.prototype.declaration = function(version, encoding, standalone) {
          var node;
          this.openCurrent();
          if (this.documentStarted) {
            throw new Error("declaration() must be the first node.");
          }
          node = new XMLDeclaration(this, version, encoding, standalone);
          this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.doctype = function(root, pubID, sysID) {
          this.openCurrent();
          if (root == null) {
            throw new Error("Missing root node name.");
          }
          if (this.root) {
            throw new Error("dtd() must come before the root node.");
          }
          this.currentNode = new XMLDocType(this, pubID, sysID);
          this.currentNode.rootNodeName = root;
          this.currentNode.children = false;
          this.currentLevel++;
          this.openTags[this.currentLevel] = this.currentNode;
          return this;
        };
        XMLDocumentCB2.prototype.dtdElement = function(name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDElement(this, name, value);
          this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          var node;
          this.openCurrent();
          node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
          this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.entity = function(name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDEntity(this, false, name, value);
          this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.pEntity = function(name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDEntity(this, true, name, value);
          this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.notation = function(name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDNotation(this, name, value);
          this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.up = function() {
          if (this.currentLevel < 0) {
            throw new Error("The document node has no parent.");
          }
          if (this.currentNode) {
            if (this.currentNode.children) {
              this.closeNode(this.currentNode);
            } else {
              this.openNode(this.currentNode);
            }
            this.currentNode = null;
          } else {
            this.closeNode(this.openTags[this.currentLevel]);
          }
          delete this.openTags[this.currentLevel];
          this.currentLevel--;
          return this;
        };
        XMLDocumentCB2.prototype.end = function() {
          while (this.currentLevel >= 0) {
            this.up();
          }
          return this.onEnd();
        };
        XMLDocumentCB2.prototype.openCurrent = function() {
          if (this.currentNode) {
            this.currentNode.children = true;
            return this.openNode(this.currentNode);
          }
        };
        XMLDocumentCB2.prototype.openNode = function(node) {
          var att, chunk, name, ref1;
          if (!node.isOpen) {
            if (!this.root && this.currentLevel === 0 && node.type === NodeType.Element) {
              this.root = node;
            }
            chunk = "";
            if (node.type === NodeType.Element) {
              this.writerOptions.state = WriterState.OpenTag;
              chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "<" + node.name;
              ref1 = node.attribs;
              for (name in ref1) {
                if (!hasProp.call(ref1, name))
                  continue;
                att = ref1[name];
                chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);
              }
              chunk += (node.children ? ">" : "/>") + this.writer.endline(node, this.writerOptions, this.currentLevel);
              this.writerOptions.state = WriterState.InsideTag;
            } else {
              this.writerOptions.state = WriterState.OpenTag;
              chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "<!DOCTYPE " + node.rootNodeName;
              if (node.pubID && node.sysID) {
                chunk += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
              } else if (node.sysID) {
                chunk += ' SYSTEM "' + node.sysID + '"';
              }
              if (node.children) {
                chunk += " [";
                this.writerOptions.state = WriterState.InsideTag;
              } else {
                this.writerOptions.state = WriterState.CloseTag;
                chunk += ">";
              }
              chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);
            }
            this.onData(chunk, this.currentLevel);
            return node.isOpen = true;
          }
        };
        XMLDocumentCB2.prototype.closeNode = function(node) {
          var chunk;
          if (!node.isClosed) {
            chunk = "";
            this.writerOptions.state = WriterState.CloseTag;
            if (node.type === NodeType.Element) {
              chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "</" + node.name + ">" + this.writer.endline(node, this.writerOptions, this.currentLevel);
            } else {
              chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "]>" + this.writer.endline(node, this.writerOptions, this.currentLevel);
            }
            this.writerOptions.state = WriterState.None;
            this.onData(chunk, this.currentLevel);
            return node.isClosed = true;
          }
        };
        XMLDocumentCB2.prototype.onData = function(chunk, level) {
          this.documentStarted = true;
          return this.onDataCallback(chunk, level + 1);
        };
        XMLDocumentCB2.prototype.onEnd = function() {
          this.documentCompleted = true;
          return this.onEndCallback();
        };
        XMLDocumentCB2.prototype.debugInfo = function(name) {
          if (name == null) {
            return "";
          } else {
            return "node: <" + name + ">";
          }
        };
        XMLDocumentCB2.prototype.ele = function() {
          return this.element.apply(this, arguments);
        };
        XMLDocumentCB2.prototype.nod = function(name, attributes, text) {
          return this.node(name, attributes, text);
        };
        XMLDocumentCB2.prototype.txt = function(value) {
          return this.text(value);
        };
        XMLDocumentCB2.prototype.dat = function(value) {
          return this.cdata(value);
        };
        XMLDocumentCB2.prototype.com = function(value) {
          return this.comment(value);
        };
        XMLDocumentCB2.prototype.ins = function(target, value) {
          return this.instruction(target, value);
        };
        XMLDocumentCB2.prototype.dec = function(version, encoding, standalone) {
          return this.declaration(version, encoding, standalone);
        };
        XMLDocumentCB2.prototype.dtd = function(root, pubID, sysID) {
          return this.doctype(root, pubID, sysID);
        };
        XMLDocumentCB2.prototype.e = function(name, attributes, text) {
          return this.element(name, attributes, text);
        };
        XMLDocumentCB2.prototype.n = function(name, attributes, text) {
          return this.node(name, attributes, text);
        };
        XMLDocumentCB2.prototype.t = function(value) {
          return this.text(value);
        };
        XMLDocumentCB2.prototype.d = function(value) {
          return this.cdata(value);
        };
        XMLDocumentCB2.prototype.c = function(value) {
          return this.comment(value);
        };
        XMLDocumentCB2.prototype.r = function(value) {
          return this.raw(value);
        };
        XMLDocumentCB2.prototype.i = function(target, value) {
          return this.instruction(target, value);
        };
        XMLDocumentCB2.prototype.att = function() {
          if (this.currentNode && this.currentNode.type === NodeType.DocType) {
            return this.attList.apply(this, arguments);
          } else {
            return this.attribute.apply(this, arguments);
          }
        };
        XMLDocumentCB2.prototype.a = function() {
          if (this.currentNode && this.currentNode.type === NodeType.DocType) {
            return this.attList.apply(this, arguments);
          } else {
            return this.attribute.apply(this, arguments);
          }
        };
        XMLDocumentCB2.prototype.ent = function(name, value) {
          return this.entity(name, value);
        };
        XMLDocumentCB2.prototype.pent = function(name, value) {
          return this.pEntity(name, value);
        };
        XMLDocumentCB2.prototype.not = function(name, value) {
          return this.notation(name, value);
        };
        return XMLDocumentCB2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLStreamWriter.js
var require_XMLStreamWriter = __commonJS({
  "node_modules/xmlbuilder/lib/XMLStreamWriter.js"(exports, module2) {
    (function() {
      var NodeType, WriterState, XMLStreamWriter, XMLWriterBase, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLWriterBase = require_XMLWriterBase();
      WriterState = require_WriterState();
      module2.exports = XMLStreamWriter = function(superClass) {
        extend(XMLStreamWriter2, superClass);
        function XMLStreamWriter2(stream, options) {
          this.stream = stream;
          XMLStreamWriter2.__super__.constructor.call(this, options);
        }
        XMLStreamWriter2.prototype.endline = function(node, options, level) {
          if (node.isLastRootNode && options.state === WriterState.CloseTag) {
            return "";
          } else {
            return XMLStreamWriter2.__super__.endline.call(this, node, options, level);
          }
        };
        XMLStreamWriter2.prototype.document = function(doc, options) {
          var child, i, j, k, len, len1, ref, ref1, results;
          ref = doc.children;
          for (i = j = 0, len = ref.length; j < len; i = ++j) {
            child = ref[i];
            child.isLastRootNode = i === doc.children.length - 1;
          }
          options = this.filterOptions(options);
          ref1 = doc.children;
          results = [];
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            child = ref1[k];
            results.push(this.writeChildNode(child, options, 0));
          }
          return results;
        };
        XMLStreamWriter2.prototype.attribute = function(att, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.attribute.call(this, att, options, level));
        };
        XMLStreamWriter2.prototype.cdata = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.cdata.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.comment = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.comment.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.declaration = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.declaration.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.docType = function(node, options, level) {
          var child, j, len, ref;
          level || (level = 0);
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          this.stream.write(this.indent(node, options, level));
          this.stream.write("<!DOCTYPE " + node.root().name);
          if (node.pubID && node.sysID) {
            this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
          } else if (node.sysID) {
            this.stream.write(' SYSTEM "' + node.sysID + '"');
          }
          if (node.children.length > 0) {
            this.stream.write(" [");
            this.stream.write(this.endline(node, options, level));
            options.state = WriterState.InsideTag;
            ref = node.children;
            for (j = 0, len = ref.length; j < len; j++) {
              child = ref[j];
              this.writeChildNode(child, options, level + 1);
            }
            options.state = WriterState.CloseTag;
            this.stream.write("]");
          }
          options.state = WriterState.CloseTag;
          this.stream.write(options.spaceBeforeSlash + ">");
          this.stream.write(this.endline(node, options, level));
          options.state = WriterState.None;
          return this.closeNode(node, options, level);
        };
        XMLStreamWriter2.prototype.element = function(node, options, level) {
          var att, child, childNodeCount, firstChildNode, j, len, name, prettySuppressed, ref, ref1;
          level || (level = 0);
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          this.stream.write(this.indent(node, options, level) + "<" + node.name);
          ref = node.attribs;
          for (name in ref) {
            if (!hasProp.call(ref, name))
              continue;
            att = ref[name];
            this.attribute(att, options, level);
          }
          childNodeCount = node.children.length;
          firstChildNode = childNodeCount === 0 ? null : node.children[0];
          if (childNodeCount === 0 || node.children.every(function(e) {
            return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === "";
          })) {
            if (options.allowEmpty) {
              this.stream.write(">");
              options.state = WriterState.CloseTag;
              this.stream.write("</" + node.name + ">");
            } else {
              options.state = WriterState.CloseTag;
              this.stream.write(options.spaceBeforeSlash + "/>");
            }
          } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null) {
            this.stream.write(">");
            options.state = WriterState.InsideTag;
            options.suppressPrettyCount++;
            prettySuppressed = true;
            this.writeChildNode(firstChildNode, options, level + 1);
            options.suppressPrettyCount--;
            prettySuppressed = false;
            options.state = WriterState.CloseTag;
            this.stream.write("</" + node.name + ">");
          } else {
            this.stream.write(">" + this.endline(node, options, level));
            options.state = WriterState.InsideTag;
            ref1 = node.children;
            for (j = 0, len = ref1.length; j < len; j++) {
              child = ref1[j];
              this.writeChildNode(child, options, level + 1);
            }
            options.state = WriterState.CloseTag;
            this.stream.write(this.indent(node, options, level) + "</" + node.name + ">");
          }
          this.stream.write(this.endline(node, options, level));
          options.state = WriterState.None;
          return this.closeNode(node, options, level);
        };
        XMLStreamWriter2.prototype.processingInstruction = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.processingInstruction.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.raw = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.raw.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.text = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.text.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.dtdAttList = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.dtdAttList.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.dtdElement = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.dtdElement.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.dtdEntity = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.dtdEntity.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.dtdNotation = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.dtdNotation.call(this, node, options, level));
        };
        return XMLStreamWriter2;
      }(XMLWriterBase);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/index.js
var require_lib = __commonJS({
  "node_modules/xmlbuilder/lib/index.js"(exports, module2) {
    (function() {
      var NodeType, WriterState, XMLDOMImplementation, XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref;
      ref = require_Utility(), assign = ref.assign, isFunction = ref.isFunction;
      XMLDOMImplementation = require_XMLDOMImplementation();
      XMLDocument = require_XMLDocument();
      XMLDocumentCB = require_XMLDocumentCB();
      XMLStringWriter = require_XMLStringWriter();
      XMLStreamWriter = require_XMLStreamWriter();
      NodeType = require_NodeType();
      WriterState = require_WriterState();
      module2.exports.create = function(name, xmldec, doctype, options) {
        var doc, root;
        if (name == null) {
          throw new Error("Root element needs a name.");
        }
        options = assign({}, xmldec, doctype, options);
        doc = new XMLDocument(options);
        root = doc.element(name);
        if (!options.headless) {
          doc.declaration(options);
          if (options.pubID != null || options.sysID != null) {
            doc.dtd(options);
          }
        }
        return root;
      };
      module2.exports.begin = function(options, onData, onEnd) {
        var ref1;
        if (isFunction(options)) {
          ref1 = [options, onData], onData = ref1[0], onEnd = ref1[1];
          options = {};
        }
        if (onData) {
          return new XMLDocumentCB(options, onData, onEnd);
        } else {
          return new XMLDocument(options);
        }
      };
      module2.exports.stringWriter = function(options) {
        return new XMLStringWriter(options);
      };
      module2.exports.streamWriter = function(stream, options) {
        return new XMLStreamWriter(stream, options);
      };
      module2.exports.implementation = new XMLDOMImplementation();
      module2.exports.nodeType = NodeType;
      module2.exports.writerState = WriterState;
    }).call(exports);
  }
});

// node_modules/xml2js/lib/builder.js
var require_builder = __commonJS({
  "node_modules/xml2js/lib/builder.js"(exports) {
    (function() {
      "use strict";
      var builder, defaults, escapeCDATA, requiresCDATA, wrapCDATA, hasProp = {}.hasOwnProperty;
      builder = require_lib();
      defaults = require_defaults().defaults;
      requiresCDATA = function(entry) {
        return typeof entry === "string" && (entry.indexOf("&") >= 0 || entry.indexOf(">") >= 0 || entry.indexOf("<") >= 0);
      };
      wrapCDATA = function(entry) {
        return "<![CDATA[" + escapeCDATA(entry) + "]]>";
      };
      escapeCDATA = function(entry) {
        return entry.replace("]]>", "]]]]><![CDATA[>");
      };
      exports.Builder = function() {
        function Builder(opts) {
          var key, ref, value;
          this.options = {};
          ref = defaults["0.2"];
          for (key in ref) {
            if (!hasProp.call(ref, key))
              continue;
            value = ref[key];
            this.options[key] = value;
          }
          for (key in opts) {
            if (!hasProp.call(opts, key))
              continue;
            value = opts[key];
            this.options[key] = value;
          }
        }
        Builder.prototype.buildObject = function(rootObj) {
          var attrkey, charkey, render, rootElement, rootName;
          attrkey = this.options.attrkey;
          charkey = this.options.charkey;
          if (Object.keys(rootObj).length === 1 && this.options.rootName === defaults["0.2"].rootName) {
            rootName = Object.keys(rootObj)[0];
            rootObj = rootObj[rootName];
          } else {
            rootName = this.options.rootName;
          }
          render = function(_this) {
            return function(element, obj) {
              var attr, child, entry, index, key, value;
              if (typeof obj !== "object") {
                if (_this.options.cdata && requiresCDATA(obj)) {
                  element.raw(wrapCDATA(obj));
                } else {
                  element.txt(obj);
                }
              } else if (Array.isArray(obj)) {
                for (index in obj) {
                  if (!hasProp.call(obj, index))
                    continue;
                  child = obj[index];
                  for (key in child) {
                    entry = child[key];
                    element = render(element.ele(key), entry).up();
                  }
                }
              } else {
                for (key in obj) {
                  if (!hasProp.call(obj, key))
                    continue;
                  child = obj[key];
                  if (key === attrkey) {
                    if (typeof child === "object") {
                      for (attr in child) {
                        value = child[attr];
                        element = element.att(attr, value);
                      }
                    }
                  } else if (key === charkey) {
                    if (_this.options.cdata && requiresCDATA(child)) {
                      element = element.raw(wrapCDATA(child));
                    } else {
                      element = element.txt(child);
                    }
                  } else if (Array.isArray(child)) {
                    for (index in child) {
                      if (!hasProp.call(child, index))
                        continue;
                      entry = child[index];
                      if (typeof entry === "string") {
                        if (_this.options.cdata && requiresCDATA(entry)) {
                          element = element.ele(key).raw(wrapCDATA(entry)).up();
                        } else {
                          element = element.ele(key, entry).up();
                        }
                      } else {
                        element = render(element.ele(key), entry).up();
                      }
                    }
                  } else if (typeof child === "object") {
                    element = render(element.ele(key), child).up();
                  } else {
                    if (typeof child === "string" && _this.options.cdata && requiresCDATA(child)) {
                      element = element.ele(key).raw(wrapCDATA(child)).up();
                    } else {
                      if (child == null) {
                        child = "";
                      }
                      element = element.ele(key, child.toString()).up();
                    }
                  }
                }
              }
              return element;
            };
          }(this);
          rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
            headless: this.options.headless,
            allowSurrogateChars: this.options.allowSurrogateChars
          });
          return render(rootElement, rootObj).end(this.options.renderOpts);
        };
        return Builder;
      }();
    }).call(exports);
  }
});

// node_modules/sax/lib/sax.js
var require_sax = __commonJS({
  "node_modules/sax/lib/sax.js"(exports) {
    (function(sax) {
      sax.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
      };
      sax.SAXParser = SAXParser;
      sax.SAXStream = SAXStream;
      sax.createStream = createStream;
      sax.MAX_BUFFER_LENGTH = 64 * 1024;
      var buffers = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      sax.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
          return new SAXParser(strict, opt);
        }
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = "";
        parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
        parser.attribList = [];
        if (parser.opt.xmlns) {
          parser.ns = Object.create(rootNS);
        }
        if (parser.opt.unquotedAttributeValues === void 0) {
          parser.opt.unquotedAttributeValues = !strict;
        }
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) {
          parser.position = parser.line = parser.column = 0;
        }
        emit(parser, "onready");
      }
      if (!Object.create) {
        Object.create = function(o) {
          function F() {
          }
          F.prototype = o;
          var newf = new F();
          return newf;
        };
      }
      if (!Object.keys) {
        Object.keys = function(o) {
          var a = [];
          for (var i in o)
            if (o.hasOwnProperty(i))
              a.push(i);
          return a;
        };
      }
      function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for (var i = 0, l = buffers.length; i < l; i++) {
          var len = parser[buffers[i]].length;
          if (len > maxAllowed) {
            switch (buffers[i]) {
              case "textNode":
                closeText(parser);
                break;
              case "cdata":
                emitNode(parser, "oncdata", parser.cdata);
                parser.cdata = "";
                break;
              case "script":
                emitNode(parser, "onscript", parser.script);
                parser.script = "";
                break;
              default:
                error(parser, "Max buffer length exceeded: " + buffers[i]);
            }
          }
          maxActual = Math.max(maxActual, len);
        }
        var m = sax.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m + parser.position;
      }
      function clearBuffers(parser) {
        for (var i = 0, l = buffers.length; i < l; i++) {
          parser[buffers[i]] = "";
        }
      }
      function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== "") {
          emitNode(parser, "oncdata", parser.cdata);
          parser.cdata = "";
        }
        if (parser.script !== "") {
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
      }
      SAXParser.prototype = {
        end: function() {
          end(this);
        },
        write,
        resume: function() {
          this.error = null;
          return this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          flushBuffers(this);
        }
      };
      var Stream;
      try {
        Stream = require("stream").Stream;
      } catch (ex) {
        Stream = function() {
        };
      }
      if (!Stream)
        Stream = function() {
        };
      var streamWraps = sax.EVENTS.filter(function(ev) {
        return ev !== "error" && ev !== "end";
      });
      function createStream(strict, opt) {
        return new SAXStream(strict, opt);
      }
      function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) {
          return new SAXStream(strict, opt);
        }
        Stream.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function() {
          me.emit("end");
        };
        this._parser.onerror = function(er) {
          me.emit("error", er);
          me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
          Object.defineProperty(me, "on" + ev, {
            get: function() {
              return me._parser["on" + ev];
            },
            set: function(h) {
              if (!h) {
                me.removeAllListeners(ev);
                me._parser["on" + ev] = h;
                return h;
              }
              me.on(ev, h);
            },
            enumerable: true,
            configurable: false
          });
        });
      }
      SAXStream.prototype = Object.create(Stream.prototype, {
        constructor: {
          value: SAXStream
        }
      });
      SAXStream.prototype.write = function(data) {
        if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
          if (!this._decoder) {
            var SD = require("string_decoder").StringDecoder;
            this._decoder = new SD("utf8");
          }
          data = this._decoder.write(data);
        }
        this._parser.write(data.toString());
        this.emit("data", data);
        return true;
      };
      SAXStream.prototype.end = function(chunk) {
        if (chunk && chunk.length) {
          this.write(chunk);
        }
        this._parser.end();
        return true;
      };
      SAXStream.prototype.on = function(ev, handler) {
        var me = this;
        if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
          me._parser["on" + ev] = function() {
            var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
            args.splice(0, 0, ev);
            me.emit.apply(me, args);
          };
        }
        return Stream.prototype.on.call(me, ev, handler);
      };
      var CDATA = "[CDATA[";
      var DOCTYPE = "DOCTYPE";
      var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
      var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
      var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
      var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function isWhitespace(c) {
        return c === " " || c === "\n" || c === "\r" || c === "	";
      }
      function isQuote(c) {
        return c === '"' || c === "'";
      }
      function isAttribEnd(c) {
        return c === ">" || isWhitespace(c);
      }
      function isMatch(regex, c) {
        return regex.test(c);
      }
      function notMatch(regex, c) {
        return !isMatch(regex, c);
      }
      var S = 0;
      sax.STATE = {
        BEGIN: S++,
        BEGIN_WHITESPACE: S++,
        TEXT: S++,
        TEXT_ENTITY: S++,
        OPEN_WAKA: S++,
        SGML_DECL: S++,
        SGML_DECL_QUOTED: S++,
        DOCTYPE: S++,
        DOCTYPE_QUOTED: S++,
        DOCTYPE_DTD: S++,
        DOCTYPE_DTD_QUOTED: S++,
        COMMENT_STARTING: S++,
        COMMENT: S++,
        COMMENT_ENDING: S++,
        COMMENT_ENDED: S++,
        CDATA: S++,
        CDATA_ENDING: S++,
        CDATA_ENDING_2: S++,
        PROC_INST: S++,
        PROC_INST_BODY: S++,
        PROC_INST_ENDING: S++,
        OPEN_TAG: S++,
        OPEN_TAG_SLASH: S++,
        ATTRIB: S++,
        ATTRIB_NAME: S++,
        ATTRIB_NAME_SAW_WHITE: S++,
        ATTRIB_VALUE: S++,
        ATTRIB_VALUE_QUOTED: S++,
        ATTRIB_VALUE_CLOSED: S++,
        ATTRIB_VALUE_UNQUOTED: S++,
        ATTRIB_VALUE_ENTITY_Q: S++,
        ATTRIB_VALUE_ENTITY_U: S++,
        CLOSE_TAG: S++,
        CLOSE_TAG_SAW_WHITE: S++,
        SCRIPT: S++,
        SCRIPT_ENDING: S++
      };
      sax.XML_ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'"
      };
      sax.ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'",
        "AElig": 198,
        "Aacute": 193,
        "Acirc": 194,
        "Agrave": 192,
        "Aring": 197,
        "Atilde": 195,
        "Auml": 196,
        "Ccedil": 199,
        "ETH": 208,
        "Eacute": 201,
        "Ecirc": 202,
        "Egrave": 200,
        "Euml": 203,
        "Iacute": 205,
        "Icirc": 206,
        "Igrave": 204,
        "Iuml": 207,
        "Ntilde": 209,
        "Oacute": 211,
        "Ocirc": 212,
        "Ograve": 210,
        "Oslash": 216,
        "Otilde": 213,
        "Ouml": 214,
        "THORN": 222,
        "Uacute": 218,
        "Ucirc": 219,
        "Ugrave": 217,
        "Uuml": 220,
        "Yacute": 221,
        "aacute": 225,
        "acirc": 226,
        "aelig": 230,
        "agrave": 224,
        "aring": 229,
        "atilde": 227,
        "auml": 228,
        "ccedil": 231,
        "eacute": 233,
        "ecirc": 234,
        "egrave": 232,
        "eth": 240,
        "euml": 235,
        "iacute": 237,
        "icirc": 238,
        "igrave": 236,
        "iuml": 239,
        "ntilde": 241,
        "oacute": 243,
        "ocirc": 244,
        "ograve": 242,
        "oslash": 248,
        "otilde": 245,
        "ouml": 246,
        "szlig": 223,
        "thorn": 254,
        "uacute": 250,
        "ucirc": 251,
        "ugrave": 249,
        "uuml": 252,
        "yacute": 253,
        "yuml": 255,
        "copy": 169,
        "reg": 174,
        "nbsp": 160,
        "iexcl": 161,
        "cent": 162,
        "pound": 163,
        "curren": 164,
        "yen": 165,
        "brvbar": 166,
        "sect": 167,
        "uml": 168,
        "ordf": 170,
        "laquo": 171,
        "not": 172,
        "shy": 173,
        "macr": 175,
        "deg": 176,
        "plusmn": 177,
        "sup1": 185,
        "sup2": 178,
        "sup3": 179,
        "acute": 180,
        "micro": 181,
        "para": 182,
        "middot": 183,
        "cedil": 184,
        "ordm": 186,
        "raquo": 187,
        "frac14": 188,
        "frac12": 189,
        "frac34": 190,
        "iquest": 191,
        "times": 215,
        "divide": 247,
        "OElig": 338,
        "oelig": 339,
        "Scaron": 352,
        "scaron": 353,
        "Yuml": 376,
        "fnof": 402,
        "circ": 710,
        "tilde": 732,
        "Alpha": 913,
        "Beta": 914,
        "Gamma": 915,
        "Delta": 916,
        "Epsilon": 917,
        "Zeta": 918,
        "Eta": 919,
        "Theta": 920,
        "Iota": 921,
        "Kappa": 922,
        "Lambda": 923,
        "Mu": 924,
        "Nu": 925,
        "Xi": 926,
        "Omicron": 927,
        "Pi": 928,
        "Rho": 929,
        "Sigma": 931,
        "Tau": 932,
        "Upsilon": 933,
        "Phi": 934,
        "Chi": 935,
        "Psi": 936,
        "Omega": 937,
        "alpha": 945,
        "beta": 946,
        "gamma": 947,
        "delta": 948,
        "epsilon": 949,
        "zeta": 950,
        "eta": 951,
        "theta": 952,
        "iota": 953,
        "kappa": 954,
        "lambda": 955,
        "mu": 956,
        "nu": 957,
        "xi": 958,
        "omicron": 959,
        "pi": 960,
        "rho": 961,
        "sigmaf": 962,
        "sigma": 963,
        "tau": 964,
        "upsilon": 965,
        "phi": 966,
        "chi": 967,
        "psi": 968,
        "omega": 969,
        "thetasym": 977,
        "upsih": 978,
        "piv": 982,
        "ensp": 8194,
        "emsp": 8195,
        "thinsp": 8201,
        "zwnj": 8204,
        "zwj": 8205,
        "lrm": 8206,
        "rlm": 8207,
        "ndash": 8211,
        "mdash": 8212,
        "lsquo": 8216,
        "rsquo": 8217,
        "sbquo": 8218,
        "ldquo": 8220,
        "rdquo": 8221,
        "bdquo": 8222,
        "dagger": 8224,
        "Dagger": 8225,
        "bull": 8226,
        "hellip": 8230,
        "permil": 8240,
        "prime": 8242,
        "Prime": 8243,
        "lsaquo": 8249,
        "rsaquo": 8250,
        "oline": 8254,
        "frasl": 8260,
        "euro": 8364,
        "image": 8465,
        "weierp": 8472,
        "real": 8476,
        "trade": 8482,
        "alefsym": 8501,
        "larr": 8592,
        "uarr": 8593,
        "rarr": 8594,
        "darr": 8595,
        "harr": 8596,
        "crarr": 8629,
        "lArr": 8656,
        "uArr": 8657,
        "rArr": 8658,
        "dArr": 8659,
        "hArr": 8660,
        "forall": 8704,
        "part": 8706,
        "exist": 8707,
        "empty": 8709,
        "nabla": 8711,
        "isin": 8712,
        "notin": 8713,
        "ni": 8715,
        "prod": 8719,
        "sum": 8721,
        "minus": 8722,
        "lowast": 8727,
        "radic": 8730,
        "prop": 8733,
        "infin": 8734,
        "ang": 8736,
        "and": 8743,
        "or": 8744,
        "cap": 8745,
        "cup": 8746,
        "int": 8747,
        "there4": 8756,
        "sim": 8764,
        "cong": 8773,
        "asymp": 8776,
        "ne": 8800,
        "equiv": 8801,
        "le": 8804,
        "ge": 8805,
        "sub": 8834,
        "sup": 8835,
        "nsub": 8836,
        "sube": 8838,
        "supe": 8839,
        "oplus": 8853,
        "otimes": 8855,
        "perp": 8869,
        "sdot": 8901,
        "lceil": 8968,
        "rceil": 8969,
        "lfloor": 8970,
        "rfloor": 8971,
        "lang": 9001,
        "rang": 9002,
        "loz": 9674,
        "spades": 9824,
        "clubs": 9827,
        "hearts": 9829,
        "diams": 9830
      };
      Object.keys(sax.ENTITIES).forEach(function(key) {
        var e = sax.ENTITIES[key];
        var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
        sax.ENTITIES[key] = s2;
      });
      for (var s in sax.STATE) {
        sax.STATE[sax.STATE[s]] = s;
      }
      S = sax.STATE;
      function emit(parser, event, data) {
        parser[event] && parser[event](data);
      }
      function emitNode(parser, nodeType, data) {
        if (parser.textNode)
          closeText(parser);
        emit(parser, nodeType, data);
      }
      function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode)
          emit(parser, "ontext", parser.textNode);
        parser.textNode = "";
      }
      function textopts(opt, text) {
        if (opt.trim)
          text = text.trim();
        if (opt.normalize)
          text = text.replace(/\s+/g, " ");
        return text;
      }
      function error(parser, er) {
        closeText(parser);
        if (parser.trackPosition) {
          er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
        }
        er = new Error(er);
        parser.error = er;
        emit(parser, "onerror", er);
        return parser;
      }
      function end(parser) {
        if (parser.sawRoot && !parser.closedRoot)
          strictFail(parser, "Unclosed root tag");
        if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
          error(parser, "Unexpected end");
        }
        closeText(parser);
        parser.c = "";
        parser.closed = true;
        emit(parser, "onend");
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
      }
      function strictFail(parser, message) {
        if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
          throw new Error("bad call to strictFail");
        }
        if (parser.strict) {
          error(parser, message);
        }
      }
      function newTag(parser) {
        if (!parser.strict)
          parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = { name: parser.tagName, attributes: {} };
        if (parser.opt.xmlns) {
          tag.ns = parent.ns;
        }
        parser.attribList.length = 0;
        emitNode(parser, "onopentagstart", tag);
      }
      function qname(name, attribute) {
        var i = name.indexOf(":");
        var qualName = i < 0 ? ["", name] : name.split(":");
        var prefix = qualName[0];
        var local = qualName[1];
        if (attribute && name === "xmlns") {
          prefix = "xmlns";
          local = "";
        }
        return { prefix, local };
      }
      function attrib(parser) {
        if (!parser.strict) {
          parser.attribName = parser.attribName[parser.looseCase]();
        }
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
          parser.attribName = parser.attribValue = "";
          return;
        }
        if (parser.opt.xmlns) {
          var qn = qname(parser.attribName, true);
          var prefix = qn.prefix;
          var local = qn.local;
          if (prefix === "xmlns") {
            if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
              strictFail(parser, "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue);
            } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
              strictFail(parser, "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue);
            } else {
              var tag = parser.tag;
              var parent = parser.tags[parser.tags.length - 1] || parser;
              if (tag.ns === parent.ns) {
                tag.ns = Object.create(parent.ns);
              }
              tag.ns[local] = parser.attribValue;
            }
          }
          parser.attribList.push([parser.attribName, parser.attribValue]);
        } else {
          parser.tag.attributes[parser.attribName] = parser.attribValue;
          emitNode(parser, "onattribute", {
            name: parser.attribName,
            value: parser.attribValue
          });
        }
        parser.attribName = parser.attribValue = "";
      }
      function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
          var tag = parser.tag;
          var qn = qname(parser.tagName);
          tag.prefix = qn.prefix;
          tag.local = qn.local;
          tag.uri = tag.ns[qn.prefix] || "";
          if (tag.prefix && !tag.uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
            tag.uri = qn.prefix;
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag.ns && parent.ns !== tag.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              emitNode(parser, "onopennamespace", {
                prefix: p,
                uri: tag.ns[p]
              });
            });
          }
          for (var i = 0, l = parser.attribList.length; i < l; i++) {
            var nv = parser.attribList[i];
            var name = nv[0];
            var value = nv[1];
            var qualName = qname(name, true);
            var prefix = qualName.prefix;
            var local = qualName.local;
            var uri = prefix === "" ? "" : tag.ns[prefix] || "";
            var a = {
              name,
              value,
              prefix,
              local,
              uri
            };
            if (prefix && prefix !== "xmlns" && !uri) {
              strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
              a.uri = prefix;
            }
            parser.tag.attributes[name] = a;
            emitNode(parser, "onattribute", a);
          }
          parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, "onopentag", parser.tag);
        if (!selfClosing) {
          if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
            parser.state = S.SCRIPT;
          } else {
            parser.state = S.TEXT;
          }
          parser.tag = null;
          parser.tagName = "";
        }
        parser.attribName = parser.attribValue = "";
        parser.attribList.length = 0;
      }
      function closeTag(parser) {
        if (!parser.tagName) {
          strictFail(parser, "Weird empty close tag.");
          parser.textNode += "</>";
          parser.state = S.TEXT;
          return;
        }
        if (parser.script) {
          if (parser.tagName !== "script") {
            parser.script += "</" + parser.tagName + ">";
            parser.tagName = "";
            parser.state = S.SCRIPT;
            return;
          }
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
        var t = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) {
          tagName = tagName[parser.looseCase]();
        }
        var closeTo = tagName;
        while (t--) {
          var close = parser.tags[t];
          if (close.name !== closeTo) {
            strictFail(parser, "Unexpected close tag");
          } else {
            break;
          }
        }
        if (t < 0) {
          strictFail(parser, "Unmatched closing tag: " + parser.tagName);
          parser.textNode += "</" + parser.tagName + ">";
          parser.state = S.TEXT;
          return;
        }
        parser.tagName = tagName;
        var s2 = parser.tags.length;
        while (s2-- > t) {
          var tag = parser.tag = parser.tags.pop();
          parser.tagName = parser.tag.name;
          emitNode(parser, "onclosetag", parser.tagName);
          var x = {};
          for (var i in tag.ns) {
            x[i] = tag.ns[i];
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (parser.opt.xmlns && tag.ns !== parent.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              var n = tag.ns[p];
              emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
            });
          }
        }
        if (t === 0)
          parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = "";
        parser.attribList.length = 0;
        parser.state = S.TEXT;
      }
      function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = "";
        if (parser.ENTITIES[entity]) {
          return parser.ENTITIES[entity];
        }
        if (parser.ENTITIES[entityLC]) {
          return parser.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === "#") {
          if (entity.charAt(1) === "x") {
            entity = entity.slice(2);
            num = parseInt(entity, 16);
            numStr = num.toString(16);
          } else {
            entity = entity.slice(1);
            num = parseInt(entity, 10);
            numStr = num.toString(10);
          }
        }
        entity = entity.replace(/^0+/, "");
        if (isNaN(num) || numStr.toLowerCase() !== entity) {
          strictFail(parser, "Invalid character entity");
          return "&" + parser.entity + ";";
        }
        return String.fromCodePoint(num);
      }
      function beginWhiteSpace(parser, c) {
        if (c === "<") {
          parser.state = S.OPEN_WAKA;
          parser.startTagPosition = parser.position;
        } else if (!isWhitespace(c)) {
          strictFail(parser, "Non-whitespace before first tag.");
          parser.textNode = c;
          parser.state = S.TEXT;
        }
      }
      function charAt(chunk, i) {
        var result = "";
        if (i < chunk.length) {
          result = chunk.charAt(i);
        }
        return result;
      }
      function write(chunk) {
        var parser = this;
        if (this.error) {
          throw this.error;
        }
        if (parser.closed) {
          return error(parser, "Cannot write after close. Assign an onready handler.");
        }
        if (chunk === null) {
          return end(parser);
        }
        if (typeof chunk === "object") {
          chunk = chunk.toString();
        }
        var i = 0;
        var c = "";
        while (true) {
          c = charAt(chunk, i++);
          parser.c = c;
          if (!c) {
            break;
          }
          if (parser.trackPosition) {
            parser.position++;
            if (c === "\n") {
              parser.line++;
              parser.column = 0;
            } else {
              parser.column++;
            }
          }
          switch (parser.state) {
            case S.BEGIN:
              parser.state = S.BEGIN_WHITESPACE;
              if (c === "\uFEFF") {
                continue;
              }
              beginWhiteSpace(parser, c);
              continue;
            case S.BEGIN_WHITESPACE:
              beginWhiteSpace(parser, c);
              continue;
            case S.TEXT:
              if (parser.sawRoot && !parser.closedRoot) {
                var starti = i - 1;
                while (c && c !== "<" && c !== "&") {
                  c = charAt(chunk, i++);
                  if (c && parser.trackPosition) {
                    parser.position++;
                    if (c === "\n") {
                      parser.line++;
                      parser.column = 0;
                    } else {
                      parser.column++;
                    }
                  }
                }
                parser.textNode += chunk.substring(starti, i - 1);
              }
              if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                parser.state = S.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else {
                if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                  strictFail(parser, "Text data outside of root node.");
                }
                if (c === "&") {
                  parser.state = S.TEXT_ENTITY;
                } else {
                  parser.textNode += c;
                }
              }
              continue;
            case S.SCRIPT:
              if (c === "<") {
                parser.state = S.SCRIPT_ENDING;
              } else {
                parser.script += c;
              }
              continue;
            case S.SCRIPT_ENDING:
              if (c === "/") {
                parser.state = S.CLOSE_TAG;
              } else {
                parser.script += "<" + c;
                parser.state = S.SCRIPT;
              }
              continue;
            case S.OPEN_WAKA:
              if (c === "!") {
                parser.state = S.SGML_DECL;
                parser.sgmlDecl = "";
              } else if (isWhitespace(c)) {
              } else if (isMatch(nameStart, c)) {
                parser.state = S.OPEN_TAG;
                parser.tagName = c;
              } else if (c === "/") {
                parser.state = S.CLOSE_TAG;
                parser.tagName = "";
              } else if (c === "?") {
                parser.state = S.PROC_INST;
                parser.procInstName = parser.procInstBody = "";
              } else {
                strictFail(parser, "Unencoded <");
                if (parser.startTagPosition + 1 < parser.position) {
                  var pad = parser.position - parser.startTagPosition;
                  c = new Array(pad).join(" ") + c;
                }
                parser.textNode += "<" + c;
                parser.state = S.TEXT;
              }
              continue;
            case S.SGML_DECL:
              if (parser.sgmlDecl + c === "--") {
                parser.state = S.COMMENT;
                parser.comment = "";
                parser.sgmlDecl = "";
                continue;
              }
              if (parser.doctype && parser.doctype !== true && parser.sgmlDecl) {
                parser.state = S.DOCTYPE_DTD;
                parser.doctype += "<!" + parser.sgmlDecl + c;
                parser.sgmlDecl = "";
              } else if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                emitNode(parser, "onopencdata");
                parser.state = S.CDATA;
                parser.sgmlDecl = "";
                parser.cdata = "";
              } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                parser.state = S.DOCTYPE;
                if (parser.doctype || parser.sawRoot) {
                  strictFail(parser, "Inappropriately located doctype declaration");
                }
                parser.doctype = "";
                parser.sgmlDecl = "";
              } else if (c === ">") {
                emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                parser.sgmlDecl = "";
                parser.state = S.TEXT;
              } else if (isQuote(c)) {
                parser.state = S.SGML_DECL_QUOTED;
                parser.sgmlDecl += c;
              } else {
                parser.sgmlDecl += c;
              }
              continue;
            case S.SGML_DECL_QUOTED:
              if (c === parser.q) {
                parser.state = S.SGML_DECL;
                parser.q = "";
              }
              parser.sgmlDecl += c;
              continue;
            case S.DOCTYPE:
              if (c === ">") {
                parser.state = S.TEXT;
                emitNode(parser, "ondoctype", parser.doctype);
                parser.doctype = true;
              } else {
                parser.doctype += c;
                if (c === "[") {
                  parser.state = S.DOCTYPE_DTD;
                } else if (isQuote(c)) {
                  parser.state = S.DOCTYPE_QUOTED;
                  parser.q = c;
                }
              }
              continue;
            case S.DOCTYPE_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.q = "";
                parser.state = S.DOCTYPE;
              }
              continue;
            case S.DOCTYPE_DTD:
              if (c === "]") {
                parser.doctype += c;
                parser.state = S.DOCTYPE;
              } else if (c === "<") {
                parser.state = S.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else if (isQuote(c)) {
                parser.doctype += c;
                parser.state = S.DOCTYPE_DTD_QUOTED;
                parser.q = c;
              } else {
                parser.doctype += c;
              }
              continue;
            case S.DOCTYPE_DTD_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.state = S.DOCTYPE_DTD;
                parser.q = "";
              }
              continue;
            case S.COMMENT:
              if (c === "-") {
                parser.state = S.COMMENT_ENDING;
              } else {
                parser.comment += c;
              }
              continue;
            case S.COMMENT_ENDING:
              if (c === "-") {
                parser.state = S.COMMENT_ENDED;
                parser.comment = textopts(parser.opt, parser.comment);
                if (parser.comment) {
                  emitNode(parser, "oncomment", parser.comment);
                }
                parser.comment = "";
              } else {
                parser.comment += "-" + c;
                parser.state = S.COMMENT;
              }
              continue;
            case S.COMMENT_ENDED:
              if (c !== ">") {
                strictFail(parser, "Malformed comment");
                parser.comment += "--" + c;
                parser.state = S.COMMENT;
              } else if (parser.doctype && parser.doctype !== true) {
                parser.state = S.DOCTYPE_DTD;
              } else {
                parser.state = S.TEXT;
              }
              continue;
            case S.CDATA:
              if (c === "]") {
                parser.state = S.CDATA_ENDING;
              } else {
                parser.cdata += c;
              }
              continue;
            case S.CDATA_ENDING:
              if (c === "]") {
                parser.state = S.CDATA_ENDING_2;
              } else {
                parser.cdata += "]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.CDATA_ENDING_2:
              if (c === ">") {
                if (parser.cdata) {
                  emitNode(parser, "oncdata", parser.cdata);
                }
                emitNode(parser, "onclosecdata");
                parser.cdata = "";
                parser.state = S.TEXT;
              } else if (c === "]") {
                parser.cdata += "]";
              } else {
                parser.cdata += "]]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.PROC_INST:
              if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else if (isWhitespace(c)) {
                parser.state = S.PROC_INST_BODY;
              } else {
                parser.procInstName += c;
              }
              continue;
            case S.PROC_INST_BODY:
              if (!parser.procInstBody && isWhitespace(c)) {
                continue;
              } else if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else {
                parser.procInstBody += c;
              }
              continue;
            case S.PROC_INST_ENDING:
              if (c === ">") {
                emitNode(parser, "onprocessinginstruction", {
                  name: parser.procInstName,
                  body: parser.procInstBody
                });
                parser.procInstName = parser.procInstBody = "";
                parser.state = S.TEXT;
              } else {
                parser.procInstBody += "?" + c;
                parser.state = S.PROC_INST_BODY;
              }
              continue;
            case S.OPEN_TAG:
              if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else {
                newTag(parser);
                if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S.OPEN_TAG_SLASH;
                } else {
                  if (!isWhitespace(c)) {
                    strictFail(parser, "Invalid character in tag name");
                  }
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.OPEN_TAG_SLASH:
              if (c === ">") {
                openTag(parser, true);
                closeTag(parser);
              } else {
                strictFail(parser, "Forward-slash in opening tag not followed by >");
                parser.state = S.ATTRIB;
              }
              continue;
            case S.ATTRIB:
              if (isWhitespace(c)) {
                continue;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (c === ">") {
                strictFail(parser, "Attribute without value");
                parser.attribValue = parser.attribName;
                attrib(parser);
                openTag(parser);
              } else if (isWhitespace(c)) {
                parser.state = S.ATTRIB_NAME_SAW_WHITE;
              } else if (isMatch(nameBody, c)) {
                parser.attribName += c;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME_SAW_WHITE:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (isWhitespace(c)) {
                continue;
              } else {
                strictFail(parser, "Attribute without value");
                parser.tag.attributes[parser.attribName] = "";
                parser.attribValue = "";
                emitNode(parser, "onattribute", {
                  name: parser.attribName,
                  value: ""
                });
                parser.attribName = "";
                if (c === ">") {
                  openTag(parser);
                } else if (isMatch(nameStart, c)) {
                  parser.attribName = c;
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.ATTRIB_VALUE:
              if (isWhitespace(c)) {
                continue;
              } else if (isQuote(c)) {
                parser.q = c;
                parser.state = S.ATTRIB_VALUE_QUOTED;
              } else {
                if (!parser.opt.unquotedAttributeValues) {
                  error(parser, "Unquoted attribute value");
                }
                parser.state = S.ATTRIB_VALUE_UNQUOTED;
                parser.attribValue = c;
              }
              continue;
            case S.ATTRIB_VALUE_QUOTED:
              if (c !== parser.q) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              parser.q = "";
              parser.state = S.ATTRIB_VALUE_CLOSED;
              continue;
            case S.ATTRIB_VALUE_CLOSED:
              if (isWhitespace(c)) {
                parser.state = S.ATTRIB;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                strictFail(parser, "No whitespace between attributes");
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_VALUE_UNQUOTED:
              if (!isAttribEnd(c)) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_U;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              if (c === ">") {
                openTag(parser);
              } else {
                parser.state = S.ATTRIB;
              }
              continue;
            case S.CLOSE_TAG:
              if (!parser.tagName) {
                if (isWhitespace(c)) {
                  continue;
                } else if (notMatch(nameStart, c)) {
                  if (parser.script) {
                    parser.script += "</" + c;
                    parser.state = S.SCRIPT;
                  } else {
                    strictFail(parser, "Invalid tagname in closing tag.");
                  }
                } else {
                  parser.tagName = c;
                }
              } else if (c === ">") {
                closeTag(parser);
              } else if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else if (parser.script) {
                parser.script += "</" + parser.tagName;
                parser.tagName = "";
                parser.state = S.SCRIPT;
              } else {
                if (!isWhitespace(c)) {
                  strictFail(parser, "Invalid tagname in closing tag");
                }
                parser.state = S.CLOSE_TAG_SAW_WHITE;
              }
              continue;
            case S.CLOSE_TAG_SAW_WHITE:
              if (isWhitespace(c)) {
                continue;
              }
              if (c === ">") {
                closeTag(parser);
              } else {
                strictFail(parser, "Invalid characters in closing tag");
              }
              continue;
            case S.TEXT_ENTITY:
            case S.ATTRIB_VALUE_ENTITY_Q:
            case S.ATTRIB_VALUE_ENTITY_U:
              var returnState;
              var buffer;
              switch (parser.state) {
                case S.TEXT_ENTITY:
                  returnState = S.TEXT;
                  buffer = "textNode";
                  break;
                case S.ATTRIB_VALUE_ENTITY_Q:
                  returnState = S.ATTRIB_VALUE_QUOTED;
                  buffer = "attribValue";
                  break;
                case S.ATTRIB_VALUE_ENTITY_U:
                  returnState = S.ATTRIB_VALUE_UNQUOTED;
                  buffer = "attribValue";
                  break;
              }
              if (c === ";") {
                var parsedEntity = parseEntity(parser);
                if (parser.opt.unparsedEntities && !Object.values(sax.XML_ENTITIES).includes(parsedEntity)) {
                  parser.entity = "";
                  parser.state = returnState;
                  parser.write(parsedEntity);
                } else {
                  parser[buffer] += parsedEntity;
                  parser.entity = "";
                  parser.state = returnState;
                }
              } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
                parser.entity += c;
              } else {
                strictFail(parser, "Invalid character in entity name");
                parser[buffer] += "&" + parser.entity + c;
                parser.entity = "";
                parser.state = returnState;
              }
              continue;
            default: {
              throw new Error(parser, "Unknown state: " + parser.state);
            }
          }
        }
        if (parser.position >= parser.bufferCheckPosition) {
          checkBufferLength(parser);
        }
        return parser;
      }
      if (!String.fromCodePoint) {
        (function() {
          var stringFromCharCode = String.fromCharCode;
          var floor = Math.floor;
          var fromCodePoint = function() {
            var MAX_SIZE = 16384;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index = -1;
            var length = arguments.length;
            if (!length) {
              return "";
            }
            var result = "";
            while (++index < length) {
              var codePoint = Number(arguments[index]);
              if (!isFinite(codePoint) || codePoint < 0 || codePoint > 1114111 || floor(codePoint) !== codePoint) {
                throw RangeError("Invalid code point: " + codePoint);
              }
              if (codePoint <= 65535) {
                codeUnits.push(codePoint);
              } else {
                codePoint -= 65536;
                highSurrogate = (codePoint >> 10) + 55296;
                lowSurrogate = codePoint % 1024 + 56320;
                codeUnits.push(highSurrogate, lowSurrogate);
              }
              if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                result += stringFromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
              }
            }
            return result;
          };
          if (Object.defineProperty) {
            Object.defineProperty(String, "fromCodePoint", {
              value: fromCodePoint,
              configurable: true,
              writable: true
            });
          } else {
            String.fromCodePoint = fromCodePoint;
          }
        })();
      }
    })(typeof exports === "undefined" ? exports.sax = {} : exports);
  }
});

// node_modules/xml2js/lib/bom.js
var require_bom = __commonJS({
  "node_modules/xml2js/lib/bom.js"(exports) {
    (function() {
      "use strict";
      exports.stripBOM = function(str) {
        if (str[0] === "\uFEFF") {
          return str.substring(1);
        } else {
          return str;
        }
      };
    }).call(exports);
  }
});

// node_modules/xml2js/lib/processors.js
var require_processors = __commonJS({
  "node_modules/xml2js/lib/processors.js"(exports) {
    (function() {
      "use strict";
      var prefixMatch;
      prefixMatch = new RegExp(/(?!xmlns)^.*:/);
      exports.normalize = function(str) {
        return str.toLowerCase();
      };
      exports.firstCharLowerCase = function(str) {
        return str.charAt(0).toLowerCase() + str.slice(1);
      };
      exports.stripPrefix = function(str) {
        return str.replace(prefixMatch, "");
      };
      exports.parseNumbers = function(str) {
        if (!isNaN(str)) {
          str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
        }
        return str;
      };
      exports.parseBooleans = function(str) {
        if (/^(?:true|false)$/i.test(str)) {
          str = str.toLowerCase() === "true";
        }
        return str;
      };
    }).call(exports);
  }
});

// node_modules/xml2js/lib/parser.js
var require_parser = __commonJS({
  "node_modules/xml2js/lib/parser.js"(exports) {
    (function() {
      "use strict";
      var bom, defaults, events, isEmpty, processItem, processors, sax, setImmediate, bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      }, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      sax = require_sax();
      events = require("events");
      bom = require_bom();
      processors = require_processors();
      setImmediate = require("timers").setImmediate;
      defaults = require_defaults().defaults;
      isEmpty = function(thing) {
        return typeof thing === "object" && thing != null && Object.keys(thing).length === 0;
      };
      processItem = function(processors2, item, key) {
        var i, len, process;
        for (i = 0, len = processors2.length; i < len; i++) {
          process = processors2[i];
          item = process(item, key);
        }
        return item;
      };
      exports.Parser = function(superClass) {
        extend(Parser, superClass);
        function Parser(opts) {
          this.parseStringPromise = bind(this.parseStringPromise, this);
          this.parseString = bind(this.parseString, this);
          this.reset = bind(this.reset, this);
          this.assignOrPush = bind(this.assignOrPush, this);
          this.processAsync = bind(this.processAsync, this);
          var key, ref, value;
          if (!(this instanceof exports.Parser)) {
            return new exports.Parser(opts);
          }
          this.options = {};
          ref = defaults["0.2"];
          for (key in ref) {
            if (!hasProp.call(ref, key))
              continue;
            value = ref[key];
            this.options[key] = value;
          }
          for (key in opts) {
            if (!hasProp.call(opts, key))
              continue;
            value = opts[key];
            this.options[key] = value;
          }
          if (this.options.xmlns) {
            this.options.xmlnskey = this.options.attrkey + "ns";
          }
          if (this.options.normalizeTags) {
            if (!this.options.tagNameProcessors) {
              this.options.tagNameProcessors = [];
            }
            this.options.tagNameProcessors.unshift(processors.normalize);
          }
          this.reset();
        }
        Parser.prototype.processAsync = function() {
          var chunk, err;
          try {
            if (this.remaining.length <= this.options.chunkSize) {
              chunk = this.remaining;
              this.remaining = "";
              this.saxParser = this.saxParser.write(chunk);
              return this.saxParser.close();
            } else {
              chunk = this.remaining.substr(0, this.options.chunkSize);
              this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
              this.saxParser = this.saxParser.write(chunk);
              return setImmediate(this.processAsync);
            }
          } catch (error1) {
            err = error1;
            if (!this.saxParser.errThrown) {
              this.saxParser.errThrown = true;
              return this.emit(err);
            }
          }
        };
        Parser.prototype.assignOrPush = function(obj, key, newValue) {
          if (!(key in obj)) {
            if (!this.options.explicitArray) {
              return obj[key] = newValue;
            } else {
              return obj[key] = [newValue];
            }
          } else {
            if (!(obj[key] instanceof Array)) {
              obj[key] = [obj[key]];
            }
            return obj[key].push(newValue);
          }
        };
        Parser.prototype.reset = function() {
          var attrkey, charkey, ontext, stack;
          this.removeAllListeners();
          this.saxParser = sax.parser(this.options.strict, {
            trim: false,
            normalize: false,
            xmlns: this.options.xmlns
          });
          this.saxParser.errThrown = false;
          this.saxParser.onerror = function(_this) {
            return function(error) {
              _this.saxParser.resume();
              if (!_this.saxParser.errThrown) {
                _this.saxParser.errThrown = true;
                return _this.emit("error", error);
              }
            };
          }(this);
          this.saxParser.onend = function(_this) {
            return function() {
              if (!_this.saxParser.ended) {
                _this.saxParser.ended = true;
                return _this.emit("end", _this.resultObject);
              }
            };
          }(this);
          this.saxParser.ended = false;
          this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
          this.resultObject = null;
          stack = [];
          attrkey = this.options.attrkey;
          charkey = this.options.charkey;
          this.saxParser.onopentag = function(_this) {
            return function(node) {
              var key, newValue, obj, processedKey, ref;
              obj = Object.create(null);
              obj[charkey] = "";
              if (!_this.options.ignoreAttrs) {
                ref = node.attributes;
                for (key in ref) {
                  if (!hasProp.call(ref, key))
                    continue;
                  if (!(attrkey in obj) && !_this.options.mergeAttrs) {
                    obj[attrkey] = Object.create(null);
                  }
                  newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];
                  processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;
                  if (_this.options.mergeAttrs) {
                    _this.assignOrPush(obj, processedKey, newValue);
                  } else {
                    obj[attrkey][processedKey] = newValue;
                  }
                }
              }
              obj["#name"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;
              if (_this.options.xmlns) {
                obj[_this.options.xmlnskey] = {
                  uri: node.uri,
                  local: node.local
                };
              }
              return stack.push(obj);
            };
          }(this);
          this.saxParser.onclosetag = function(_this) {
            return function() {
              var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s, xpath;
              obj = stack.pop();
              nodeName = obj["#name"];
              if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
                delete obj["#name"];
              }
              if (obj.cdata === true) {
                cdata = obj.cdata;
                delete obj.cdata;
              }
              s = stack[stack.length - 1];
              if (obj[charkey].match(/^\s*$/) && !cdata) {
                emptyStr = obj[charkey];
                delete obj[charkey];
              } else {
                if (_this.options.trim) {
                  obj[charkey] = obj[charkey].trim();
                }
                if (_this.options.normalize) {
                  obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
                }
                obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];
                if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                  obj = obj[charkey];
                }
              }
              if (isEmpty(obj)) {
                if (typeof _this.options.emptyTag === "function") {
                  obj = _this.options.emptyTag();
                } else {
                  obj = _this.options.emptyTag !== "" ? _this.options.emptyTag : emptyStr;
                }
              }
              if (_this.options.validator != null) {
                xpath = "/" + function() {
                  var i, len, results;
                  results = [];
                  for (i = 0, len = stack.length; i < len; i++) {
                    node = stack[i];
                    results.push(node["#name"]);
                  }
                  return results;
                }().concat(nodeName).join("/");
                (function() {
                  var err;
                  try {
                    return obj = _this.options.validator(xpath, s && s[nodeName], obj);
                  } catch (error1) {
                    err = error1;
                    return _this.emit("error", err);
                  }
                })();
              }
              if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === "object") {
                if (!_this.options.preserveChildrenOrder) {
                  node = Object.create(null);
                  if (_this.options.attrkey in obj) {
                    node[_this.options.attrkey] = obj[_this.options.attrkey];
                    delete obj[_this.options.attrkey];
                  }
                  if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                    node[_this.options.charkey] = obj[_this.options.charkey];
                    delete obj[_this.options.charkey];
                  }
                  if (Object.getOwnPropertyNames(obj).length > 0) {
                    node[_this.options.childkey] = obj;
                  }
                  obj = node;
                } else if (s) {
                  s[_this.options.childkey] = s[_this.options.childkey] || [];
                  objClone = Object.create(null);
                  for (key in obj) {
                    if (!hasProp.call(obj, key))
                      continue;
                    objClone[key] = obj[key];
                  }
                  s[_this.options.childkey].push(objClone);
                  delete obj["#name"];
                  if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                    obj = obj[charkey];
                  }
                }
              }
              if (stack.length > 0) {
                return _this.assignOrPush(s, nodeName, obj);
              } else {
                if (_this.options.explicitRoot) {
                  old = obj;
                  obj = Object.create(null);
                  obj[nodeName] = old;
                }
                _this.resultObject = obj;
                _this.saxParser.ended = true;
                return _this.emit("end", _this.resultObject);
              }
            };
          }(this);
          ontext = function(_this) {
            return function(text) {
              var charChild, s;
              s = stack[stack.length - 1];
              if (s) {
                s[charkey] += text;
                if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text.replace(/\\n/g, "").trim() !== "")) {
                  s[_this.options.childkey] = s[_this.options.childkey] || [];
                  charChild = {
                    "#name": "__text__"
                  };
                  charChild[charkey] = text;
                  if (_this.options.normalize) {
                    charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim();
                  }
                  s[_this.options.childkey].push(charChild);
                }
                return s;
              }
            };
          }(this);
          this.saxParser.ontext = ontext;
          return this.saxParser.oncdata = function(_this) {
            return function(text) {
              var s;
              s = ontext(text);
              if (s) {
                return s.cdata = true;
              }
            };
          }(this);
        };
        Parser.prototype.parseString = function(str, cb) {
          var err;
          if (cb != null && typeof cb === "function") {
            this.on("end", function(result) {
              this.reset();
              return cb(null, result);
            });
            this.on("error", function(err2) {
              this.reset();
              return cb(err2);
            });
          }
          try {
            str = str.toString();
            if (str.trim() === "") {
              this.emit("end", null);
              return true;
            }
            str = bom.stripBOM(str);
            if (this.options.async) {
              this.remaining = str;
              setImmediate(this.processAsync);
              return this.saxParser;
            }
            return this.saxParser.write(str).close();
          } catch (error1) {
            err = error1;
            if (!(this.saxParser.errThrown || this.saxParser.ended)) {
              this.emit("error", err);
              return this.saxParser.errThrown = true;
            } else if (this.saxParser.ended) {
              throw err;
            }
          }
        };
        Parser.prototype.parseStringPromise = function(str) {
          return new Promise(function(_this) {
            return function(resolve, reject) {
              return _this.parseString(str, function(err, value) {
                if (err) {
                  return reject(err);
                } else {
                  return resolve(value);
                }
              });
            };
          }(this));
        };
        return Parser;
      }(events);
      exports.parseString = function(str, a, b) {
        var cb, options, parser;
        if (b != null) {
          if (typeof b === "function") {
            cb = b;
          }
          if (typeof a === "object") {
            options = a;
          }
        } else {
          if (typeof a === "function") {
            cb = a;
          }
          options = {};
        }
        parser = new exports.Parser(options);
        return parser.parseString(str, cb);
      };
      exports.parseStringPromise = function(str, a) {
        var options, parser;
        if (typeof a === "object") {
          options = a;
        }
        parser = new exports.Parser(options);
        return parser.parseStringPromise(str);
      };
    }).call(exports);
  }
});

// node_modules/xml2js/lib/xml2js.js
var require_xml2js = __commonJS({
  "node_modules/xml2js/lib/xml2js.js"(exports) {
    (function() {
      "use strict";
      var builder, defaults, parser, processors, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key))
            child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      defaults = require_defaults();
      builder = require_builder();
      parser = require_parser();
      processors = require_processors();
      exports.defaults = defaults.defaults;
      exports.processors = processors;
      exports.ValidationError = function(superClass) {
        extend(ValidationError, superClass);
        function ValidationError(message) {
          this.message = message;
        }
        return ValidationError;
      }(Error);
      exports.Builder = builder.Builder;
      exports.Parser = parser.Parser;
      exports.parseString = parser.parseString;
      exports.parseStringPromise = parser.parseStringPromise;
    }).call(exports);
  }
});

// src/main.ts
__export(exports, {
  default: () => BibleLinkPlugin
});
var import_obsidian4 = __toModule(require("obsidian"));

// src/database.ts
var import_obsidian = __toModule(require("obsidian"));
var fs = __toModule(require("fs"));
var path = __toModule(require("path"));
var _BibleDatabase = class {
  constructor(plugin, dataPath = "data") {
    this.isInitialized = false;
    this.isUnloading = false;
    this.plugin = plugin;
    this.dataPath = dataPath;
    console.log(`[BibleLink] Using plugin data path: ${this.dataPath}`);
    this.data = {
      translations: [],
      verses: [],
      nextTranslationId: 1,
      nextVerseId: 1
    };
  }
  async initialize() {
    if (this.isInitialized)
      return;
    try {
      await this.loadData();
      this.isInitialized = true;
    } catch (error) {
      console.error("Failed to initialize Bible database:", error);
      this.isInitialized = true;
      throw error;
    }
  }
  async loadData() {
    try {
      const filePath = path.join(this.plugin.app.vault.adapter.basePath, ".obsidian", "plugins", "obsidian-biblelink", this.dataPath, "bible_data.json");
      console.log(`[BibleLink] [loadData] Checking for data file at: ${filePath}`);
      if (fs.existsSync(filePath)) {
        const content = fs.readFileSync(filePath, "utf8");
        console.log(`[BibleLink] [loadData] File found. First 200 chars:`, content.slice(0, 200));
        this.data = JSON.parse(content);
        console.log(`[BibleLink] [loadData] Loaded: ${this.data.translations.length} translations, ${this.data.verses.length} verses`);
      } else {
        console.log("[BibleLink] [loadData] No existing Bible data file found, starting fresh");
      }
    } catch (error) {
      console.log("[BibleLink] [loadData] Starting with fresh Bible database due to error:", error);
    }
  }
  async saveData() {
    try {
      await this.ensureDirectoryExists();
      const filePath = path.join(this.plugin.app.vault.adapter.basePath, ".obsidian", "plugins", "obsidian-biblelink", this.dataPath, "bible_data.json");
      const content = JSON.stringify(this.data, null, 2);
      console.log(`[BibleLink] [saveData] Saving to: ${filePath}`);
      console.log(`[BibleLink] [saveData] Data (first 200 chars):`, content.slice(0, 200));
      fs.writeFileSync(filePath, content, "utf8");
      console.log(`[BibleLink] [saveData] Bible data saved successfully: ${this.data.translations.length} translations, ${this.data.verses.length} verses`);
    } catch (error) {
      console.error("[BibleLink] [saveData] Failed to save Bible data:", error);
      if (!this.isUnloading) {
        new import_obsidian.Notice("Failed to save Bible data");
      }
      if (!this.isUnloading) {
        throw error;
      }
    }
  }
  async ensureDirectoryExists() {
    try {
      const dirPath = path.join(this.plugin.app.vault.adapter.basePath, ".obsidian", "plugins", "obsidian-biblelink", this.dataPath);
      if (!fs.existsSync(dirPath)) {
        fs.mkdirSync(dirPath, { recursive: true });
        console.log(`[BibleLink] Created directory: ${dirPath}`);
      }
    } catch (error) {
      console.log("[BibleLink] Directory creation error (may already exist):", error);
    }
  }
  getTranslations() {
    return [...this.data.translations].sort((a, b) => a.abbreviation.localeCompare(b.abbreviation));
  }
  getBooks() {
    const books = new Set();
    for (const verse of this.data.verses) {
      books.add(verse.book);
    }
    const bookArray = Array.from(books);
    return bookArray.sort((a, b) => {
      const aIndex = _BibleDatabase.CHRONOLOGICAL_BOOK_ORDER.indexOf(a);
      const bIndex = _BibleDatabase.CHRONOLOGICAL_BOOK_ORDER.indexOf(b);
      if (aIndex !== -1 && bIndex !== -1) {
        return aIndex - bIndex;
      }
      if (aIndex !== -1)
        return -1;
      if (bIndex !== -1)
        return 1;
      return a.localeCompare(b);
    });
  }
  getChaptersForBook(book, translationAbbr) {
    const translation = this.data.translations.find((t) => t.abbreviation === translationAbbr);
    if (!translation)
      return [];
    const chapters = new Set();
    for (const verse of this.data.verses) {
      if (verse.translation_id === translation.id && verse.book === book) {
        chapters.add(verse.chapter);
      }
    }
    return Array.from(chapters).sort((a, b) => a - b);
  }
  getVersesForChapter(book, chapter, translationAbbr) {
    const translation = this.data.translations.find((t) => t.abbreviation === translationAbbr);
    if (!translation)
      return [];
    const verses = new Set();
    for (const verse of this.data.verses) {
      if (verse.translation_id === translation.id && verse.book === book && verse.chapter === chapter) {
        verses.add(verse.verse);
      }
    }
    return Array.from(verses).sort((a, b) => a - b);
  }
  getVerse(book, chapter, verse, translationAbbr) {
    const translation = this.data.translations.find((t) => t.abbreviation === translationAbbr);
    if (!translation)
      return null;
    return this.data.verses.find((v) => v.translation_id === translation.id && v.book === book && v.chapter === chapter && v.verse === verse) || null;
  }
  async addTranslation(name, abbreviation, language = "English", category = "Standard", processingRules = []) {
    const existing = this.data.translations.find((t) => t.abbreviation === abbreviation);
    if (existing) {
      throw new Error(`Translation with abbreviation '${abbreviation}' already exists`);
    }
    const id = this.data.nextTranslationId++;
    this.data.translations.push({
      id,
      name,
      abbreviation,
      language,
      category,
      processingRules
    });
    console.log(`Added translation: ${name} (${abbreviation}) with ID ${id}`);
    await this.saveData();
    return id;
  }
  async updateTranslation(id, name, abbreviation, language, category, processingRules) {
    const translation = this.data.translations.find((t) => t.id === id);
    if (!translation) {
      throw new Error("Translation not found");
    }
    if (translation.abbreviation !== abbreviation && this.data.translations.some((t) => t.abbreviation === abbreviation)) {
      throw new Error("Translation abbreviation already exists");
    }
    translation.name = name;
    translation.abbreviation = abbreviation;
    translation.language = language;
    translation.category = category;
    translation.processingRules = processingRules;
    await this.saveData();
  }
  async addVerse(translationId, book, chapter, verse, text, saveImmediately = true) {
    this.data.verses.push({
      id: this.data.nextVerseId++,
      translation_id: translationId,
      book,
      chapter,
      verse,
      text
    });
    if (saveImmediately) {
      await this.saveData();
    }
  }
  async addVersesBatch(verses) {
    if (verses.length === 0) {
      console.log("[BibleLink] No verses to add");
      return;
    }
    const startId = this.data.nextVerseId;
    for (const verse of verses) {
      this.data.verses.push({
        id: this.data.nextVerseId++,
        translation_id: verse.translationId,
        book: verse.book,
        chapter: verse.chapter,
        verse: verse.verse,
        text: verse.text
      });
    }
    console.log(`[BibleLink] Added ${verses.length} verses (IDs ${startId}-${this.data.nextVerseId - 1})`);
    console.log(`[BibleLink] Total verses in memory: ${this.data.verses.length}`);
    await this.saveData();
    console.log(`[BibleLink] After save - Total verses in memory: ${this.data.verses.length}`);
  }
  async removeTranslation(abbreviation) {
    const translationIndex = this.data.translations.findIndex((t) => t.abbreviation === abbreviation);
    if (translationIndex === -1) {
      return false;
    }
    const translation = this.data.translations[translationIndex];
    this.data.verses = this.data.verses.filter((v) => v.translation_id !== translation.id);
    this.data.translations.splice(translationIndex, 1);
    await this.saveData();
    return true;
  }
  async importFromSQLite(sqliteData) {
    if (sqliteData.translations && sqliteData.verses) {
      for (const translation of sqliteData.translations) {
        await this.addTranslation(translation.name, translation.abbreviation);
      }
      const versesToAdd = [];
      for (const verse of sqliteData.verses) {
        const translation = this.data.translations.find((t) => t.id === verse.translation_id);
        if (translation) {
          versesToAdd.push({
            translationId: translation.id,
            book: verse.book,
            chapter: verse.chapter,
            verse: verse.verse,
            text: verse.text
          });
        }
      }
      if (versesToAdd.length > 0) {
        await this.addVersesBatch(versesToAdd);
      }
    }
  }
  async importFromXML(xmlData) {
    console.log("XML import not yet implemented");
  }
  getDatabaseStats() {
    return {
      translations: this.data.translations.length,
      verses: this.data.verses.length
    };
  }
  verifyTranslationExists(abbreviation) {
    return this.data.translations.some((t) => t.abbreviation === abbreviation);
  }
  getTranslationStats(abbreviation) {
    const translation = this.data.translations.find((t) => t.abbreviation === abbreviation);
    if (!translation)
      return null;
    const translationVerses = this.data.verses.filter((v) => v.translation_id === translation.id);
    const books = [...new Set(translationVerses.map((v) => v.book))].sort();
    return {
      name: translation.name,
      verseCount: translationVerses.length,
      books
    };
  }
  applyProcessingRules(text, translationAbbr) {
    const translation = this.data.translations.find((t) => t.abbreviation === translationAbbr);
    if (!translation || !translation.processingRules) {
      return text;
    }
    let processedText = text;
    for (const rule of translation.processingRules) {
      try {
        const regex = new RegExp(rule.regex, "g");
        if (rule.escape) {
          processedText = processedText.replace(regex, (...args) => {
            let result = rule.formatting;
            for (let i = 1; i < args.length - 2; i++) {
              const group = args[i];
              const escaped = this.escapeHtml(group);
              result = result.replace(new RegExp(`\\$${i}`, "g"), escaped);
            }
            result = result.replace(/\$&/g, this.escapeHtml(args[0]));
            return result;
          });
        } else {
          processedText = processedText.replace(regex, rule.formatting);
        }
      } catch (error) {
        console.warn(`Invalid regex in processing rule for ${translationAbbr}: ${rule.regex}`, error);
      }
    }
    return processedText;
  }
  escapeHtml(str) {
    return str.replace(/[&<>\[\]]/g, (c) => {
      switch (c) {
        case "&":
          return "&amp;";
        case "<":
          return "&lt;";
        case ">":
          return "&gt;";
        case "[":
          return "&#91;";
        case "]":
          return "&#93;";
        default:
          return c;
      }
    });
  }
  getDataFilePath() {
    return path.join(this.plugin.app.vault.adapter.basePath, ".obsidian", "plugins", "obsidian-biblelink", this.dataPath, "bible_data.json");
  }
  dataFileExists() {
    return fs.existsSync(this.getDataFilePath());
  }
  async close() {
    this.isUnloading = true;
    try {
      await this.saveData();
    } catch (error) {
      console.error("Error during database close:", error);
    }
  }
};
var BibleDatabase = _BibleDatabase;
BibleDatabase.CHRONOLOGICAL_BOOK_ORDER = [
  "Genesis",
  "Exodus",
  "Leviticus",
  "Numbers",
  "Deuteronomy",
  "Joshua",
  "Judges",
  "Ruth",
  "1 Samuel",
  "2 Samuel",
  "1 Kings",
  "2 Kings",
  "1 Chronicles",
  "2 Chronicles",
  "Ezra",
  "Nehemiah",
  "Esther",
  "Job",
  "Psalms",
  "Proverbs",
  "Ecclesiastes",
  "Song of Solomon",
  "Isaiah",
  "Jeremiah",
  "Lamentations",
  "Ezekiel",
  "Daniel",
  "Hosea",
  "Joel",
  "Amos",
  "Obadiah",
  "Jonah",
  "Micah",
  "Nahum",
  "Habakkuk",
  "Zephaniah",
  "Haggai",
  "Zechariah",
  "Malachi",
  "Matthew",
  "Mark",
  "Luke",
  "John",
  "Acts",
  "Romans",
  "1 Corinthians",
  "2 Corinthians",
  "Galatians",
  "Ephesians",
  "Philippians",
  "Colossians",
  "1 Thessalonians",
  "2 Thessalonians",
  "1 Timothy",
  "2 Timothy",
  "Titus",
  "Philemon",
  "Hebrews",
  "James",
  "1 Peter",
  "2 Peter",
  "1 John",
  "2 John",
  "3 John",
  "Jude",
  "Revelation"
];

// src/selector.ts
var import_obsidian2 = __toModule(require("obsidian"));
var BibleSelectorModal = class extends import_obsidian2.Modal {
  constructor(app, plugin, onSubmit) {
    super(app);
    this.plugin = plugin;
    this.onSubmit = onSubmit;
    this.selectedBook = null;
    this.selectedStartChapter = 1;
    this.selectedEndChapter = null;
    this.selectedStartVerse = 1;
    this.selectedEndVerse = null;
    this.selectedTranslation = null;
    this.selectedOutputType = "codeblock";
    this.selectedOptions = [];
    this.selectedBooks = new Set();
    this.selectedChapters = new Set();
    this.selectedVerses = new Set();
    this.db = plugin.db;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.selectedOutputType = this.plugin.settings.modalOutputType;
    this.selectedOptions = [...this.plugin.settings.modalOptions];
    contentEl.createEl("h2", { text: "Insert Bible Reference" });
    const referenceSetting = new import_obsidian2.Setting(contentEl).setName("Reference").setDesc("Enter a reference (e.g., John 1:13-25) or use the selectors below.").addText((text) => {
      text.setPlaceholder("e.g., John 1:13-25").onChange((value) => {
        this.handleReferenceInput(value);
      });
      this.referenceInput = text;
    });
    this.referenceWarning = contentEl.createEl("div", { cls: "biblelink-ref-warning" });
    this.referenceWarning.style.color = "var(--text-warning)";
    this.referenceWarning.style.display = "none";
    new import_obsidian2.Setting(contentEl).setName("Translation").setDesc("Choose a Bible translation").addDropdown((dropdown) => {
      this.translationDropdown = dropdown;
      const translations = this.db.getTranslations();
      const translationOptions = {};
      translations.forEach((trans) => {
        translationOptions[trans.abbreviation] = `${trans.name} (${trans.abbreviation})`;
      });
      dropdown.addOptions(translationOptions).setValue(this.plugin.settings.defaultTranslation).onChange((value) => {
        this.selectedTranslation = value;
        this.renderBookGrid(bookGridContainer);
        this.renderChapterGrid(chapterGridContainer);
        this.renderVerseGrid(verseGridContainer);
      });
    });
    const bookGridContainer = contentEl.createDiv({ cls: "biblelink-book-grid-container" });
    this.renderBookGrid(bookGridContainer);
    const chapterGridContainer = contentEl.createDiv({ cls: "biblelink-chapter-grid-container" });
    this.renderChapterGrid(chapterGridContainer);
    const verseGridContainer = contentEl.createDiv({ cls: "biblelink-verse-grid-container" });
    this.renderVerseGrid(verseGridContainer);
    new import_obsidian2.Setting(contentEl).setName("Output Type").setDesc("Choose how to insert the reference").addDropdown((dropdown) => dropdown.addOption("text", "Full Verse Text").addOption("link", "Literal Word Link").addOption("codeblock", "Code Block").setValue(this.selectedOutputType).onChange((value) => {
      this.selectedOutputType = value;
      this.plugin.settings.modalOutputType = this.selectedOutputType;
      this.plugin.saveSettings();
      this.updateOptionsSection();
    }));
    const optionsContainer = contentEl.createDiv();
    this.updateOptionsSection(optionsContainer);
    const submitButton = new import_obsidian2.Setting(contentEl).addButton((button) => button.setButtonText("Insert").setCta().onClick(() => {
      this.insertReference();
    }));
    this.injectBibleGridStyles();
  }
  injectBibleGridStyles() {
    if (document.getElementById("biblelink-modal-style"))
      return;
    const style = document.createElement("style");
    style.id = "biblelink-modal-style";
    style.textContent = `
        .biblelink-book-grid-container,
        .biblelink-chapter-grid-container,
        .biblelink-verse-grid-container {
            margin-bottom: 1.2em;
        }
        .biblelink-book-grid,
        .biblelink-chapter-grid,
        .biblelink-verse-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
            gap: 0.5em;
            max-height: 200px;
            overflow-y: auto;
            padding: 0.5em 0;
            background: var(--background-secondary-alt, #23272e);
            border-radius: 8px;
        }
        .biblelink-book-btn,
        .biblelink-chapter-btn,
        .biblelink-verse-btn {
            background: var(--background-primary, #181a20);
            color: var(--text-normal, #e0e0e0);
            border: none;
            border-radius: 6px;
            padding: 0.6em 0.8em;
            font-size: 1em;
            font-family: inherit;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            transition: background 0.15s, color 0.15s, box-shadow 0.15s, border 0.15s;
            outline: none;
        }
        .biblelink-book-btn:hover,
        .biblelink-chapter-btn:hover,
        .biblelink-verse-btn:hover {
            background: var(--interactive-accent, #3a7afe);
            color: #fff;
        }
        .biblelink-book-btn.selected,
        .biblelink-chapter-btn.selected,
        .biblelink-verse-btn.selected {
            background: var(--color-accent, #3a7afe);
            color: #fff;
            font-weight: 600;
            border: 2px solid var(--color-accent-2, #1e4fa3);
            box-shadow: 0 2px 8px rgba(58,122,254,0.15);
        }
        .biblelink-selectall-btn {
            background: var(--background-modifier-hover, #2a2d34);
            color: var(--text-muted, #b0b0b0);
            border: none;
            border-radius: 6px;
            padding: 0.4em 0.8em;
            margin-bottom: 0.5em;
            font-size: 0.95em;
            cursor: pointer;
            transition: background 0.15s, color 0.15s;
        }
        .biblelink-selectall-btn:hover {
            background: var(--interactive-accent, #3a7afe);
            color: #fff;
        }
        .biblelink-book-grid::-webkit-scrollbar,
        .biblelink-chapter-grid::-webkit-scrollbar,
        .biblelink-verse-grid::-webkit-scrollbar {
            width: 8px;
            background: transparent;
        }
        .biblelink-book-grid::-webkit-scrollbar-thumb,
        .biblelink-chapter-grid::-webkit-scrollbar-thumb,
        .biblelink-verse-grid::-webkit-scrollbar-thumb {
            background: var(--background-modifier-border, #444);
            border-radius: 4px;
        }
        @media (max-width: 600px) {
            .biblelink-book-grid,
            .biblelink-chapter-grid,
            .biblelink-verse-grid {
                grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
            }
            .biblelink-book-btn,
            .biblelink-chapter-btn,
            .biblelink-verse-btn {
                font-size: 0.95em;
                padding: 0.5em 0.5em;
            }
        }
        `;
    document.head.appendChild(style);
  }
  renderBookGrid(container) {
    container.empty();
    const books = this.db.getBooks();
    if (!books || books.length === 0)
      return;
    const grid = container.createDiv({ cls: "biblelink-book-grid" });
    books.forEach((book) => {
      const btn = grid.createEl("button", {
        text: book,
        cls: "biblelink-book-btn"
      });
      if (this.selectedBook === book) {
        btn.addClass("selected");
      }
      btn.onclick = (e) => {
        this.selectedBook = book;
        this.selectedStartChapter = 1;
        this.selectedEndChapter = null;
        this.selectedStartVerse = 1;
        this.selectedEndVerse = null;
        this.renderBookGrid(container);
        this.renderChapterGrid(document.querySelector(".biblelink-chapter-grid-container"));
        this.renderVerseGrid(document.querySelector(".biblelink-verse-grid-container"));
        this.updateReferenceInputFromSelection();
        this.updatePreview();
      };
    });
  }
  renderChapterGrid(container) {
    container.empty();
    if (!this.selectedBook)
      return;
    const chapters = this.db.getChaptersForBook(this.selectedBook, this.selectedTranslation || this.plugin.settings.defaultTranslation);
    if (!chapters || chapters.length === 0)
      return;
    const grid = container.createDiv({ cls: "biblelink-chapter-grid" });
    const selectAllBtn = container.createEl("button", { text: "Select All Chapters", cls: "biblelink-selectall-btn" });
    selectAllBtn.onclick = () => {
      this.selectedChapters = new Set(chapters);
      this.renderChapterGrid(container);
      this.renderVerseGrid(document.querySelector(".biblelink-verse-grid-container"));
      this.updateReferenceInputFromSelection();
    };
    chapters.forEach((chapter) => {
      const btn = grid.createEl("button", {
        text: chapter.toString(),
        cls: "biblelink-chapter-btn"
      });
      if (this.selectedChapters.has(chapter) || this.selectedStartChapter === chapter || this.selectedEndChapter && chapter >= this.selectedStartChapter && chapter <= this.selectedEndChapter) {
        btn.addClass("selected");
      }
      btn.onclick = (e) => {
        if (e.ctrlKey || e.metaKey) {
          if (this.selectedChapters.has(chapter)) {
            this.selectedChapters.delete(chapter);
          } else {
            this.selectedChapters.add(chapter);
          }
        } else if (e.shiftKey && this.selectedStartChapter) {
          const start = Math.min(this.selectedStartChapter, chapter);
          const end = Math.max(this.selectedStartChapter, chapter);
          for (let c = start; c <= end; c++) {
            this.selectedChapters.add(c);
          }
        } else {
          this.selectedChapters = new Set([chapter]);
        }
        this.selectedStartChapter = chapter;
        this.selectedEndChapter = chapter;
        this.selectedStartVerse = 1;
        this.selectedEndVerse = null;
        this.renderChapterGrid(container);
        this.renderVerseGrid(document.querySelector(".biblelink-verse-grid-container"));
        this.updateReferenceInputFromSelection();
      };
    });
  }
  renderVerseGrid(container) {
    container.empty();
    if (!this.selectedBook || !this.selectedStartChapter)
      return;
    const verses = this.db.getVersesForChapter(this.selectedBook, this.selectedStartChapter, this.selectedTranslation || this.plugin.settings.defaultTranslation);
    if (!verses || verses.length === 0)
      return;
    const grid = container.createDiv({ cls: "biblelink-verse-grid" });
    const selectAllBtn = container.createEl("button", { text: "Select All Verses", cls: "biblelink-selectall-btn" });
    selectAllBtn.onclick = () => {
      this.selectedVerses = new Set(verses);
      this.renderVerseGrid(container);
      this.updateReferenceInputFromSelection();
    };
    verses.forEach((verse) => {
      const btn = grid.createEl("button", {
        text: verse.toString(),
        cls: "biblelink-verse-btn"
      });
      if (this.selectedVerses.has(verse) || this.selectedStartVerse === verse || this.selectedEndVerse && verse >= this.selectedStartVerse && verse <= this.selectedEndVerse) {
        btn.addClass("selected");
      }
      btn.onclick = (e) => {
        if (e.ctrlKey || e.metaKey) {
          if (this.selectedVerses.has(verse)) {
            this.selectedVerses.delete(verse);
          } else {
            this.selectedVerses.add(verse);
          }
        } else if (e.shiftKey && this.selectedStartVerse) {
          const start = Math.min(this.selectedStartVerse, verse);
          const end = Math.max(this.selectedStartVerse, verse);
          for (let v = start; v <= end; v++) {
            this.selectedVerses.add(v);
          }
        } else {
          this.selectedVerses = new Set([verse]);
        }
        this.selectedStartVerse = verse;
        this.selectedEndVerse = verse;
        this.renderVerseGrid(container);
        this.updateReferenceInputFromSelection();
      };
    });
  }
  updateReferenceInputFromSelection() {
    if (this.referenceInput) {
      let ref = "";
      if (this.selectedBook) {
        ref += this.selectedBook;
        if (this.selectedChapters.size > 0) {
          const chapters = Array.from(this.selectedChapters).sort((a, b) => a - b);
          ref += " " + chapters.join(",");
        } else if (this.selectedStartChapter) {
          ref += " " + this.selectedStartChapter;
        }
        if (this.selectedVerses.size > 0) {
          const verses = Array.from(this.selectedVerses).sort((a, b) => a - b);
          ref += ":" + verses.join(",");
        } else if (this.selectedStartVerse) {
          ref += ":" + this.selectedStartVerse;
        }
      }
      this.referenceInput.setValue(ref);
    }
  }
  updateChapterDropdown(container) {
    if (!this.selectedBook)
      return;
    const chapters = this.db.getChaptersForBook(this.selectedBook, this.selectedTranslation || this.plugin.settings.defaultTranslation);
    if (!chapters || chapters.length === 0)
      return;
    const target = container || document.querySelector(".chapter-container");
    if (!target)
      return;
    target.empty();
    target.addClass("chapter-container");
    new import_obsidian2.Setting(target).setName("Start Chapter").addDropdown((dropdown) => {
      const chapterOptions = {};
      chapters.forEach((chapter) => {
        chapterOptions[chapter.toString()] = chapter.toString();
      });
      dropdown.addOptions(chapterOptions).setValue(this.selectedStartChapter.toString()).onChange((value) => {
        this.selectedStartChapter = parseInt(value);
        if (!this.selectedEndChapter || this.selectedEndChapter < this.selectedStartChapter) {
          this.selectedEndChapter = this.selectedStartChapter;
        }
        this.updateEndChapterDropdown(target);
        this.updateVerseDropdown();
      });
    });
    this.updateEndChapterDropdown(target);
    if (this.referenceInput) {
      let ref = this.selectedBook ? this.selectedBook + " " + this.selectedStartChapter : "";
      if (this.selectedStartVerse && this.selectedStartVerse !== 0) {
        ref += ":" + this.selectedStartVerse;
        if (this.selectedEndVerse && this.selectedEndVerse !== this.selectedStartVerse) {
          ref += "-" + this.selectedEndVerse;
        }
      }
      this.referenceInput.setValue(ref);
    }
  }
  updateEndChapterDropdown(container) {
    if (!this.selectedBook)
      return;
    const chapters = this.db.getChaptersForBook(this.selectedBook, this.selectedTranslation || this.plugin.settings.defaultTranslation);
    if (!chapters || chapters.length === 0)
      return;
    new import_obsidian2.Setting(container).setName("End Chapter").addDropdown((dropdown) => {
      const chapterOptions = {};
      chapters.filter((c) => c >= this.selectedStartChapter).forEach((chapter) => {
        chapterOptions[chapter.toString()] = chapter.toString();
      });
      dropdown.addOptions(chapterOptions).setValue((this.selectedEndChapter || this.selectedStartChapter).toString()).onChange((value) => {
        this.selectedEndChapter = parseInt(value);
        this.updateVerseDropdown();
      });
    });
  }
  updateVerseDropdown(container) {
    if (!this.selectedBook || !this.selectedStartChapter)
      return;
    const target = container || document.querySelector(".verse-container");
    if (!target)
      return;
    target.empty();
    target.addClass("verse-container");
    const startVerses = this.db.getVersesForChapter(this.selectedBook, this.selectedStartChapter, this.selectedTranslation || this.plugin.settings.defaultTranslation);
    if (startVerses && startVerses.length > 0) {
      new import_obsidian2.Setting(target).setName("Start Verse").addDropdown((dropdown) => {
        const verseOptions = {
          "0": "Entire Chapter"
        };
        startVerses.forEach((verse) => {
          verseOptions[verse.toString()] = verse.toString();
        });
        dropdown.addOptions(verseOptions).setValue(this.selectedStartVerse.toString()).onChange((value) => {
          const verseNum = parseInt(value);
          this.selectedStartVerse = verseNum;
          if (verseNum === 0) {
            this.selectedEndVerse = null;
            this.selectedEndChapter = null;
          }
          this.updateEndVerseDropdown(target);
        });
      });
    }
    if (this.selectedStartVerse !== 0) {
      this.updateEndVerseDropdown(target);
    }
    if (this.referenceInput) {
      let ref = this.selectedBook ? this.selectedBook + " " + this.selectedStartChapter : "";
      if (this.selectedStartVerse && this.selectedStartVerse !== 0) {
        ref += ":" + this.selectedStartVerse;
        if (this.selectedEndVerse && this.selectedEndVerse !== this.selectedStartVerse) {
          ref += "-" + this.selectedEndVerse;
        }
      }
      this.referenceInput.setValue(ref);
    }
  }
  updateEndVerseDropdown(container) {
    if (this.selectedStartVerse === 0)
      return;
    const endVerses = this.db.getVersesForChapter(this.selectedBook, this.selectedEndChapter || this.selectedStartChapter, this.selectedTranslation || this.plugin.settings.defaultTranslation);
    if (!endVerses || endVerses.length === 0)
      return;
    new import_obsidian2.Setting(container).setName("End Verse").addDropdown((dropdown) => {
      const verseOptions = {};
      const minVerse = this.selectedEndChapter === this.selectedStartChapter ? this.selectedStartVerse : 1;
      endVerses.filter((v) => v >= minVerse).forEach((verse) => {
        verseOptions[verse.toString()] = verse.toString();
      });
      dropdown.addOptions(verseOptions).setValue((this.selectedEndVerse || this.selectedStartVerse).toString()).onChange((value) => {
        this.selectedEndVerse = parseInt(value);
      });
    });
  }
  updateOptionsSection(container) {
    if (this.selectedOutputType !== "codeblock")
      return;
    const target = container || document.querySelector(".options-container");
    if (!target)
      return;
    target.empty();
    target.addClass("options-container");
    target.createEl("h3", { text: "Code Block Options" });
    new import_obsidian2.Setting(target).setName("Show Verse Numbers").setDesc("Include verse numbers in the output.").addToggle((toggle) => toggle.setValue(this.selectedOptions.includes("verse")).onChange((value) => {
      this.updateOption("verse", value);
      this.plugin.settings.modalOptions = [...this.selectedOptions];
      this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(target).setName("Show Chapter Numbers").setDesc("Include chapter numbers in the output.").addToggle((toggle) => toggle.setValue(this.selectedOptions.includes("chapter")).onChange((value) => {
      this.updateOption("chapter", value);
      this.plugin.settings.modalOptions = [...this.selectedOptions];
      this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(target).setName("Red Letter Text").setDesc("Highlight words of Jesus in red.").addToggle((toggle) => toggle.setValue(this.selectedOptions.includes("red-text")).onChange((value) => {
      this.updateOption("red-text", value);
      this.plugin.settings.modalOptions = [...this.selectedOptions];
      this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(target).setName("Add External Link").setDesc("Add a link to view the verse on Bible Gateway.").addToggle((toggle) => toggle.setValue(this.selectedOptions.includes("link")).onChange((value) => {
      this.updateOption("link", value);
      this.plugin.settings.modalOptions = [...this.selectedOptions];
      this.plugin.saveSettings();
    }));
  }
  updateOption(option, enabled) {
    if (enabled && !this.selectedOptions.includes(option)) {
      this.selectedOptions.push(option);
    } else if (!enabled) {
      this.selectedOptions = this.selectedOptions.filter((o) => o !== option);
    }
  }
  insertReference() {
    if (!this.selectedBook) {
      new import_obsidian2.Notice("Please select a book");
      return;
    }
    const translation = this.selectedTranslation || this.plugin.settings.defaultTranslation;
    if (!translation) {
      new import_obsidian2.Notice("Please select a translation");
      return;
    }
    let reference = `${this.selectedBook} ${this.selectedStartChapter}`;
    if (this.selectedStartVerse !== 0) {
      reference += `:${this.selectedStartVerse}`;
      if (this.selectedEndChapter && this.selectedEndChapter !== this.selectedStartChapter) {
        reference += `-${this.selectedBook} ${this.selectedEndChapter}:${this.selectedEndVerse}`;
      } else if (this.selectedEndVerse && this.selectedEndVerse !== this.selectedStartVerse) {
        reference += `-${this.selectedEndVerse}`;
      }
    } else if (this.selectedEndChapter && this.selectedEndChapter !== this.selectedStartChapter) {
      reference += `-${this.selectedEndChapter}`;
    }
    this.onSubmit(reference, translation, this.selectedOutputType, this.selectedOptions);
    this.close();
  }
  handleReferenceInput(value) {
    if (!value || value.trim() === "") {
      this.referenceWarning.style.display = "none";
      this.selectedChapters.clear();
      this.selectedVerses.clear();
      return;
    }
    const match = value.match(/^([1-3]? ?[A-Za-z ]+)\s+(\d+)(?::(\d+)(?:-(\d+))?)?$/);
    if (!match) {
      this.referenceWarning.style.display = "";
      this.referenceWarning.textContent = "Unrecognized reference format.";
      return;
    }
    this.referenceWarning.style.display = "none";
    const [, book, chapter, startVerse, endVerse] = match;
    const bookName = book.trim();
    const chapterNum = parseInt(chapter);
    const startVerseNum = startVerse ? parseInt(startVerse) : 1;
    const endVerseNum = endVerse ? parseInt(endVerse) : startVerse ? startVerseNum : null;
    const books = this.db.getBooks();
    const foundBook = books.find((b) => b.toLowerCase() === bookName.toLowerCase());
    if (!foundBook) {
      this.referenceWarning.style.display = "";
      this.referenceWarning.textContent = "Book not found.";
      return;
    }
    this.selectedChapters.clear();
    this.selectedVerses.clear();
    this.selectedBook = foundBook;
    this.selectedStartChapter = chapterNum;
    this.selectedEndChapter = chapterNum;
    this.selectedStartVerse = startVerseNum;
    this.selectedEndVerse = endVerseNum;
    if (!this.selectedTranslation) {
      this.selectedTranslation = this.plugin.settings.defaultTranslation;
    }
    if (this.translationDropdown) {
      this.translationDropdown.setValue(this.selectedTranslation);
    }
    this.renderBookGrid(document.querySelector(".biblelink-book-grid-container"));
    this.renderChapterGrid(document.querySelector(".biblelink-chapter-grid-container"));
    this.renderVerseGrid(document.querySelector(".biblelink-verse-grid-container"));
    this.updateReferenceInputFromSelection();
  }
};

// src/settings.ts
var import_obsidian3 = __toModule(require("obsidian"));
var import_xml2js = __toModule(require_xml2js());
var DEFAULT_SETTINGS = {
  defaultTranslation: "ASV",
  outputType: "codeblock",
  showTranslationAbbr: true,
  showBookAbbr: false,
  enableShortcuts: true,
  shortcuts: {
    "jn316": "John 3:16",
    "gen11": "Genesis 1:1",
    "ps231": "Psalm 23:1",
    "rom828": "Romans 8:28",
    "jn11": "John 1:1"
  },
  enableDataviewMetadata: true,
  dataviewMetadataFields: ["book", "chapter", "verse", "translation", "text", "reference", "language", "category"],
  codeBlockBackgroundColor: "#f8f9fa",
  codeBlockHeadingStyle: "detailed",
  codeBlockTextColor: "#2c3e50",
  codeBlockVerseNumberColor: "#7f8c8d",
  codeBlockLanguage: "bible",
  modalOutputType: "codeblock",
  modalOptions: []
};
var AVAILABLE_TRANSLATIONS = {
  "ASV": { name: "American Standard Version (1901)", language: "en", category: "English" },
  "KJV": { name: "King James Version", language: "en", category: "English" },
  "WEB": { name: "World English Bible", language: "en", category: "English" },
  "YLT": { name: "Young's Literal Translation (1898)", language: "en", category: "English" },
  "BBE": { name: "Bible in Basic English (1949/1964)", language: "en", category: "English" },
  "AKJV": { name: "American King James Version", language: "en", category: "English" },
  "Webster": { name: "Webster Bible", language: "en", category: "English" },
  "Tyndale": { name: "William Tyndale Bible (1525/1530)", language: "en", category: "Historical" },
  "Wycliffe": { name: "John Wycliffe Bible (c.1395)", language: "enm", category: "Historical" },
  "BSB": { name: "Berean Standard Bible", language: "en", category: "English" },
  "CPDV": { name: "Catholic Public Domain Version", language: "en", category: "English" },
  "UKJV": { name: "Updated King James Version", language: "en", category: "English" },
  "Twenty": { name: "Twentieth Century New Testament", language: "en", category: "English" },
  "Anderson": { name: "Henry Tompkins Anderson's 1864 New Testament", language: "en", category: "Historical" },
  "ACV": { name: "A Conservative Version", language: "en", category: "English" },
  "SpaRV": { name: "La Santa Biblia Reina-Valera (1909)", language: "es", category: "Spanish" },
  "SpaRV1865": { name: "La Santa Biblia Reina-Valera (1865)", language: "es", category: "Spanish" },
  "SpaRVG": { name: "Reina Valera G\xF3mez", language: "es", category: "Spanish" },
  "SpaPlatense": { name: "Biblia Platense (Straubinger)", language: "es", category: "Spanish" },
  "Vulgate": { name: "Latin Vulgate", language: "la", category: "Latin" },
  "VulgClementine": { name: "Clementine Vulgate", language: "la", category: "Latin" },
  "Byz": { name: "The New Testament in the Original Greek: Byzantine Textform 2013", language: "grc", category: "Greek" },
  "TR": { name: "Textus Receptus (1550/1894)", language: "grc", category: "Greek" },
  "WLC": { name: "Westminster Leningrad Codex", language: "hbo", category: "Hebrew" },
  "StatResGNT": { name: "Statistical Restoration Greek New Testament", language: "grc", category: "Greek" },
  "VulgSistine": { name: "Vulgata Sistina", language: "la", category: "Latin" },
  "VulgHetzenauer": { name: "Vulgata Clementina, Hetzenauer editore", language: "la", category: "Latin" },
  "VulgConte": { name: "Vulgata Clementina, Conte editore", language: "la", category: "Latin" },
  "Swe1917": { name: "Swedish Bible (1917)", language: "sv", category: "Swedish" },
  "SweKarlXII": { name: "Svenska Karl XII:s Bibel (1703)", language: "sv", category: "Historical" },
  "SweKarlXII1873": { name: "Svenska Karl XII:s Bibel (1873)", language: "sv", category: "Historical" },
  "UkrOgienko": { name: "\u0423\u043A\u0440\u0430\u0457\u043D\u0441\u044C\u043A\u0430 \u0411\u0456\u0431\u043B\u0456\u044F. \u041F\u0435\u0440\u0435\u043A\u043B\u0430\u0434 \u0406\u0432\u0430\u043D\u0430 \u041E\u0433\u0456\u0454\u043D\u043A\u0430.", language: "uk", category: "Ukrainian" },
  "Viet": { name: "Kinh Th\xE1nh Ti\u1EBFng Vi\u1EC7t (1934)", language: "vi", category: "Vietnamese" },
  "ThaiKJV": { name: "Thai King James Version", language: "th", category: "Thai" },
  "TagAngBiblia": { name: "Philippine Bible Society (1905)", language: "tl", category: "Tagalog" },
  "Tausug": { name: "Tausug Kitab Injil", language: "tsg", category: "Tausug" },
  "TpiKJPB": { name: "King Jems Pisin Baibel", language: "tpi", category: "Tok Pisin" },
  "BurJudson": { name: "1835 Judson Burmese Bible", language: "my", category: "Burmese" },
  "Alb": { name: "Albanian Bible", language: "sq", category: "Albanian" },
  "ArmEastern": { name: "Eastern Armenian Bible", language: "hy", category: "Armenian" },
  "BeaMRK": { name: "The Gospel of Mark in Beaver (Danezaa)", language: "bea", category: "Indigenous" },
  "SrKDEkavski": { name: "Serbian Bible Dani\u010Di\u0107-Karad\u017Ei\u0107 Ekavski", language: "sr", category: "Serbian" },
  "SrKDIjekav": { name: "Serbian Bible Dani\u010Di\u0107-Karad\u017Ei\u0107 Ijekavski", language: "sr", category: "Serbian" },
  "Wulfila": { name: "Bishop Wulfila Gothic Bible", language: "got", category: "Gothic" },
  "sml_BL_2008": { name: "Kitab Awal-Jaman maka Kitab Injil", language: "sml", category: "Indigenous" },
  "vlsJoNT": { name: "Het Nieuwe Testament by Nicolaas De Jonge", language: "vls", category: "Dutch" }
};
var BibleLinkSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.filterText = "";
    this.editingAbbr = null;
    this.editingName = "";
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "BibleLink Settings" });
    containerEl.createEl("h3", { text: "Basic Settings" });
    new import_obsidian3.Setting(containerEl).setName("Default Translation").setDesc("Choose your preferred Bible translation.").addDropdown((dropdown) => {
      const translations = this.plugin.db.getTranslations();
      const translationOptions = {};
      translations.forEach((trans) => {
        translationOptions[trans.abbreviation] = `${trans.name} (${trans.abbreviation})`;
      });
      dropdown.addOptions(translationOptions).setValue(this.plugin.settings.defaultTranslation).onChange(async (value) => {
        this.plugin.settings.defaultTranslation = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian3.Setting(containerEl).setName("Default Output Type").setDesc("Choose how references are inserted.").addDropdown((dropdown) => dropdown.addOption("text", "Full Verse Text").addOption("link", "Literal Word Link").addOption("codeblock", "Code Block").setValue(this.plugin.settings.outputType).onChange(async (value) => {
      this.plugin.settings.outputType = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Show Translation Abbreviation").setDesc("Include translation abbreviation in the output.").addToggle((toggle) => toggle.setValue(this.plugin.settings.showTranslationAbbr).onChange(async (value) => {
      this.plugin.settings.showTranslationAbbr = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Show Book Abbreviations").setDesc("Use abbreviated book names (e.g., Jn instead of John).").addToggle((toggle) => toggle.setValue(this.plugin.settings.showBookAbbr).onChange(async (value) => {
      this.plugin.settings.showBookAbbr = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Code Block Styling" });
    new import_obsidian3.Setting(containerEl).setName("Background Color").setDesc("Background color for Bible verse code blocks.").addColorPicker((colorPicker) => colorPicker.setValue(this.plugin.settings.codeBlockBackgroundColor).onChange(async (value) => {
      this.plugin.settings.codeBlockBackgroundColor = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Heading Style").setDesc("Style for the reference heading in code blocks.").addDropdown((dropdown) => dropdown.addOption("none", "No Heading").addOption("simple", "Simple (John 3:16)").addOption("detailed", "Detailed (John 3:16 ASV)").setValue(this.plugin.settings.codeBlockHeadingStyle).onChange(async (value) => {
      this.plugin.settings.codeBlockHeadingStyle = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Text Color").setDesc("Color for the verse text in code blocks.").addColorPicker((colorPicker) => colorPicker.setValue(this.plugin.settings.codeBlockTextColor).onChange(async (value) => {
      this.plugin.settings.codeBlockTextColor = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Verse Number Color").setDesc("Color for verse numbers in code blocks.").addColorPicker((colorPicker) => colorPicker.setValue(this.plugin.settings.codeBlockVerseNumberColor).onChange(async (value) => {
      this.plugin.settings.codeBlockVerseNumberColor = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Code Block Language").setDesc("The language identifier for Bible verse code blocks.").addText((text) => text.setPlaceholder("bible").setValue(this.plugin.settings.codeBlockLanguage).onChange(async (value) => {
      this.plugin.settings.codeBlockLanguage = value;
      await this.plugin.saveSettings();
    }));
    const exampleContainer = containerEl.createDiv();
    exampleContainer.createEl("h4", { text: "Code Block Examples" });
    exampleContainer.createEl("p", {
      text: "Use options in square brackets after the language identifier to customize the output:"
    });
    const syntaxExample = exampleContainer.createDiv({ cls: "biblelink-syntax-example" });
    syntaxExample.createEl("p", {
      text: "Syntax: ```bible [option1,option2,option3]",
      cls: "biblelink-syntax-text"
    });
    const examples = [
      {
        label: "Basic verse (no options):",
        code: `\`\`\`${this.plugin.settings.codeBlockLanguage}
NASB 1 John 3:17
\`\`\``
      },
      {
        label: "With link option (shows a link to the verse):",
        code: `\`\`\`${this.plugin.settings.codeBlockLanguage}
NASB Matthew 8:8-40 [link]
\`\`\``
      },
      {
        label: "With verse option (displays numbers per verse):",
        code: `\`\`\`${this.plugin.settings.codeBlockLanguage}
NASB 1 Corinthians 1:2-3 [verse]
\`\`\``
      },
      {
        label: "With chapter option (displays each chapter as Chapter X):",
        code: `\`\`\`${this.plugin.settings.codeBlockLanguage}
NASB Psalm 23 [chapter]
\`\`\``
      },
      {
        label: "Multiple options (comma-separated):",
        code: `\`\`\`${this.plugin.settings.codeBlockLanguage}
NASB John 3:16-18 [verse,chapter,link]
\`\`\``
      }
    ];
    for (const ex of examples) {
      const exampleDiv = exampleContainer.createDiv({ cls: "biblelink-example-item" });
      exampleDiv.createEl("div", { text: ex.label, cls: "biblelink-example-label" });
      const codeBlock = exampleDiv.createEl("pre", { cls: "biblelink-example-code" });
      codeBlock.createEl("code", { text: ex.code });
    }
    containerEl.createEl("h3", { text: "Bible Reference Shortcuts" });
    this.renderShortcutsSection(containerEl);
    containerEl.createEl("h3", { text: "Dataview Integration" });
    new import_obsidian3.Setting(containerEl).setName("Enable Dataview Metadata").setDesc("Add rich metadata to Bible verses for Dataview queries.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableDataviewMetadata).onChange(async (value) => {
      this.plugin.settings.enableDataviewMetadata = value;
      await this.plugin.saveSettings();
    }));
    if (this.plugin.settings.enableDataviewMetadata) {
      const metadataContainer = containerEl.createDiv();
      metadataContainer.createEl("p", {
        text: "Available metadata fields: book, chapter, verse, translation, text, reference, language, category"
      });
      const queryContainer = metadataContainer.createDiv();
      queryContainer.createEl("h4", { text: "How to Query Bible Verses" });
      queryContainer.createEl("p", {
        text: "Use Dataview queries to search and display Bible verses. You can filter by translation, book, chapter, verse, or search within the text content."
      });
      const exampleQuery = `\`\`\`dataview
TABLE book, chapter, verse, translation
FROM "Bible"
WHERE translation = "ASV"
SORT book, chapter, verse
\`\`\``;
      const codeBlock = queryContainer.createEl("pre");
      codeBlock.createEl("code", { text: exampleQuery });
    }
    containerEl.createEl("h3", { text: "Translation Management" });
    const uploadSection = containerEl.createDiv({ cls: "biblelink-upload-section" });
    uploadSection.createEl("h4", { text: "Upload Custom Translation" });
    const uploadDesc = uploadSection.createEl("p");
    uploadDesc.innerHTML = 'Upload your own Bible translation files. <strong>XML format is recommended</strong> and can be downloaded from <a href="https://github.com/scrollmapper/bible_databases" target="_blank">scrollmapper/bible_databases</a>.';
    new import_obsidian3.Setting(uploadSection).setName("Upload Translation").setDesc("Choose a file to upload (SQLite or XML format).").addButton((button) => button.setButtonText("Upload XML").setClass("mod-cta").onClick(() => this.uploadXMLFile())).addButton((button) => button.setButtonText("Upload SQLite").onClick(() => this.uploadSQLiteFile()));
    this.displayCurrentTranslations(containerEl);
  }
  displayCurrentTranslations(containerEl) {
    const sectionHeader = containerEl.createDiv({ cls: "biblelink-translations-header" });
    sectionHeader.createEl("h4", { text: "Installed Translations" });
    const filterContainer = containerEl.createDiv({ cls: "biblelink-filter-container" });
    const filterInput = filterContainer.createEl("input", {
      type: "text",
      placeholder: "Search translations...",
      cls: "biblelink-filter-input"
    });
    const tableContainer = containerEl.createDiv({ cls: "biblelink-table-container" });
    let sortField = "name";
    let sortAsc = true;
    const renderTable = () => {
      tableContainer.empty();
      const table = tableContainer.createEl("table", { cls: "biblelink-translation-table" });
      const thead = table.createEl("thead");
      const headerRow = thead.createEl("tr");
      const createSortableHeader = (text, field) => {
        const th = headerRow.createEl("th");
        th.createSpan({ text });
        if (sortField === field) {
          th.createSpan({ text: sortAsc ? " \u2193" : " \u2191" });
        }
        th.onclick = () => {
          if (sortField === field) {
            sortAsc = !sortAsc;
          } else {
            sortField = field;
            sortAsc = true;
          }
          renderTable();
        };
      };
      createSortableHeader("Translation Name", "name");
      createSortableHeader("Abbreviation", "abbreviation");
      createSortableHeader("Language", "language");
      createSortableHeader("Category", "category");
      headerRow.createEl("th", { text: "Actions" });
      const tbody = table.createEl("tbody");
      let translations = this.plugin.db.getTranslations().map((t) => ({
        ...t,
        ...AVAILABLE_TRANSLATIONS[t.abbreviation],
        installed: true
      }));
      const filterText = filterInput.value.toLowerCase();
      if (filterText) {
        translations = translations.filter((t) => {
          var _a, _b;
          return t.name.toLowerCase().includes(filterText) || t.abbreviation.toLowerCase().includes(filterText) || ((_a = t.language) == null ? void 0 : _a.toLowerCase().includes(filterText)) || ((_b = t.category) == null ? void 0 : _b.toLowerCase().includes(filterText));
        });
      }
      translations.sort((a, b) => {
        const aVal = a[sortField] || "";
        const bVal = b[sortField] || "";
        return (sortAsc ? 1 : -1) * aVal.localeCompare(bVal);
      });
      if (translations.length === 0) {
        const emptyRow = tbody.createEl("tr");
        emptyRow.createEl("td", {
          text: "No translations installed.",
          attr: { colspan: "5" }
        });
        return;
      }
      translations.forEach((trans) => {
        const row = tbody.createEl("tr");
        if (this.editingAbbr === trans.abbreviation) {
          const nameCell = row.createEl("td");
          const nameInput = nameCell.createEl("input", {
            type: "text",
            value: trans.name,
            cls: "biblelink-edit-input",
            placeholder: "Translation Name"
          });
          const abbrCell = row.createEl("td");
          const abbrInput = abbrCell.createEl("input", {
            type: "text",
            value: trans.abbreviation,
            cls: "biblelink-edit-input",
            placeholder: "Abbreviation (e.g., KJV)"
          });
          row.createEl("td", { text: trans.language || "" });
          row.createEl("td", { text: trans.category || "" });
          const actionCell = row.createEl("td", { cls: "biblelink-translation-actions" });
          actionCell.createEl("button", { text: "Save", cls: "mod-cta" }).onclick = async () => {
            var _a, _b;
            const newName = nameInput.value.trim();
            const newAbbr = abbrInput.value.trim().toUpperCase();
            if (!newName || !newAbbr) {
              new import_obsidian3.Notice("Name and abbreviation are required");
              return;
            }
            if (newAbbr !== trans.abbreviation && this.plugin.db.getTranslations().some((t) => t.abbreviation === newAbbr)) {
              new import_obsidian3.Notice("Abbreviation already exists");
              return;
            }
            const oldAbbr = trans.abbreviation;
            trans.name = newName;
            trans.abbreviation = newAbbr;
            if (this.plugin.settings.defaultTranslation === oldAbbr) {
              this.plugin.settings.defaultTranslation = newAbbr;
              await this.plugin.saveSettings();
            }
            await ((_b = (_a = this.plugin.db).saveData) == null ? void 0 : _b.call(_a));
            this.editingAbbr = null;
            renderTable();
            new import_obsidian3.Notice("Translation updated");
          };
          actionCell.createEl("button", { text: "Cancel" }).onclick = () => {
            this.editingAbbr = null;
            renderTable();
          };
        } else {
          row.createEl("td", { text: trans.name });
          row.createEl("td", { text: trans.abbreviation });
          row.createEl("td", { text: trans.language || "" });
          row.createEl("td", { text: trans.category || "" });
          const actionCell = row.createEl("td", { cls: "biblelink-translation-actions" });
          if (trans.abbreviation !== "ASV") {
            actionCell.createEl("button", { text: "Edit" }).onclick = () => {
              const translation = this.plugin.db.getTranslations().find((t) => t.abbreviation === trans.abbreviation);
              if (translation) {
                new TranslationEditModal(this.app, translation.name, translation.abbreviation, translation.language, translation.category, translation.processingRules, async (name, abbreviation, language, category, processingRules) => {
                  try {
                    await this.plugin.db.updateTranslation(translation.id, name, abbreviation, language, category, processingRules);
                    new import_obsidian3.Notice("Translation updated successfully");
                    renderTable();
                  } catch (error) {
                    new import_obsidian3.Notice(`Error updating translation: ${error.message}`);
                  }
                }, true).open();
              }
            };
            actionCell.createEl("button", {
              text: "Remove",
              cls: "mod-warning"
            }).onclick = () => {
              this.confirmRemoveTranslation(trans.abbreviation, trans.name);
            };
          } else {
            actionCell.createEl("span", {
              text: "(Built-in)",
              cls: "biblelink-builtin-label"
            });
          }
        }
      });
    };
    filterInput.addEventListener("input", renderTable);
    renderTable();
    const css = `
            .biblelink-translations-header {
                margin-bottom: 16px;
            }
            .biblelink-filter-container {
                margin-bottom: 16px;
            }
            .biblelink-filter-input {
                width: 100%;
                max-width: 300px;
                padding: 8px 12px;
                border: 1px solid var(--background-modifier-border);
                border-radius: 4px;
                background: var(--background-primary);
                color: var(--text-normal);
            }
            .biblelink-filter-input:focus {
                outline: none;
                border-color: var(--interactive-accent);
                box-shadow: 0 0 0 2px var(--interactive-accent-hover);
            }
            .biblelink-table-container {
                margin-top: 16px;
                border: 1px solid var(--background-modifier-border);
                border-radius: 8px;
                overflow: hidden;
            }
            .biblelink-translation-table {
                width: 100%;
                border-collapse: collapse;
                background: var(--background-primary);
            }
            .biblelink-translation-table th {
                background: var(--background-secondary);
                padding: 12px 16px;
                text-align: left;
                font-weight: 600;
                color: var(--text-normal);
                border-bottom: 1px solid var(--background-modifier-border);
                cursor: pointer;
                user-select: none;
            }
            .biblelink-translation-table th:hover {
                background: var(--background-modifier-hover);
            }
            .biblelink-translation-table td {
                padding: 12px 16px;
                border-bottom: 1px solid var(--background-modifier-border);
                color: var(--text-normal);
            }
            .biblelink-translation-table tr:hover {
                background: var(--background-modifier-hover);
            }
            .biblelink-translation-table tr:last-child td {
                border-bottom: none;
            }
            .biblelink-translation-actions {
                display: flex;
                gap: 8px;
                align-items: center;
            }
            .biblelink-translation-actions button {
                padding: 4px 8px;
                font-size: 12px;
                border-radius: 4px;
                border: 1px solid var(--background-modifier-border);
                background: var(--background-primary);
                color: var(--text-normal);
                cursor: pointer;
            }
            .biblelink-translation-actions button:hover {
                background: var(--background-modifier-hover);
            }
            .biblelink-translation-actions button.mod-cta {
                background: var(--interactive-accent);
                color: var(--text-on-accent);
                border-color: var(--interactive-accent);
            }
            .biblelink-translation-actions button.mod-warning {
                background: var(--text-error);
                color: var(--text-on-accent);
                border-color: var(--text-error);
            }
            .biblelink-builtin-label {
                color: var(--text-muted);
                font-style: italic;
                font-size: 12px;
            }
            .biblelink-edit-input {
                width: 100%;
                padding: 4px 8px;
                border: 1px solid var(--background-modifier-border);
                border-radius: 4px;
                background: var(--background-primary);
                color: var(--text-normal);
            }
            .biblelink-upload-section {
                margin-bottom: 24px;
                padding: 16px;
                background: var(--background-secondary);
                border-radius: 8px;
                border: 1px solid var(--background-modifier-border);
            }
            .biblelink-upload-section h4 {
                margin-top: 0;
                margin-bottom: 8px;
            }
            .biblelink-upload-section p {
                margin-bottom: 16px;
                color: var(--text-muted);
            }
        `;
    const styleEl = document.head.querySelector("#biblelink-table-styles") || document.head.createEl("style", { attr: { id: "biblelink-table-styles" } });
    styleEl.textContent = css;
    const exampleCss = `
            .biblelink-syntax-example {
                background: var(--background-secondary);
                padding: 12px;
                border-radius: 6px;
                margin-bottom: 16px;
                border-left: 4px solid var(--interactive-accent);
            }
            .biblelink-syntax-text {
                margin: 0;
                font-family: monospace;
                font-weight: 600;
                color: var(--text-normal);
            }
            .biblelink-example-item {
                margin-bottom: 16px;
                padding: 12px;
                background: var(--background-secondary);
                border-radius: 6px;
                border: 1px solid var(--background-modifier-border);
            }
            .biblelink-example-label {
                font-weight: 600;
                margin-bottom: 8px;
                color: var(--text-normal);
            }
            .biblelink-example-code {
                margin: 0;
                background: var(--background-primary);
                border: 1px solid var(--background-modifier-border);
                border-radius: 4px;
            }
            .biblelink-example-code code {
                color: var(--text-normal);
            }
        `;
    const exampleStyleEl = document.head.querySelector("#biblelink-example-styles") || document.head.createEl("style", { attr: { id: "biblelink-example-styles" } });
    exampleStyleEl.textContent = exampleCss;
  }
  async uploadSQLiteFile() {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = ".sqlite,.db";
    input.onchange = async (event) => {
      var _a;
      const file = (_a = event.target.files) == null ? void 0 : _a[0];
      if (file) {
        await this.processSQLiteFile(file);
      }
    };
    input.click();
  }
  async processSQLiteFile(file) {
    try {
      new import_obsidian3.Notice(`Processing ${file.name}...`);
      const translationName = file.name.replace(/\.(sqlite|db)$/i, "");
      const abbreviation = translationName.toUpperCase();
      const modal = new TranslationEditModal(this.app, translationName, abbreviation, "English", "Standard", [], async (name, abbr, language, category, processingRules) => {
        try {
          const existingTranslations = this.plugin.db.getTranslations();
          if (existingTranslations.some((t) => t.abbreviation === abbr)) {
            throw new Error(`Translation ${abbr} already exists`);
          }
          const translationId = await this.plugin.db.addTranslation(name, abbr, language, category, processingRules);
          const sampleVerses = [
            { book: "John", chapter: 3, verse: 16, text: "Sample verse from uploaded file" },
            { book: "Genesis", chapter: 1, verse: 1, text: "Sample verse from uploaded file" }
          ];
          const versesToAdd = sampleVerses.map((verse) => ({
            translationId,
            book: verse.book,
            chapter: verse.chapter,
            verse: verse.verse,
            text: verse.text
          }));
          await this.plugin.db.addVersesBatch(versesToAdd);
          new import_obsidian3.Notice(`Successfully imported sample data from ${file.name}`);
          this.display();
        } catch (error) {
          console.error("SQLite import error:", error);
          new import_obsidian3.Notice(`Failed to import ${file.name}: ${error.message}`);
        }
      }, false);
      modal.open();
    } catch (error) {
      console.error("SQLite import error:", error);
      new import_obsidian3.Notice(`Failed to import ${file.name}: ${error.message}`);
    }
  }
  uploadXMLFile() {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = ".xml";
    input.onchange = async (event) => {
      var _a;
      const file = (_a = event.target.files) == null ? void 0 : _a[0];
      if (file) {
        await this.processXMLFile(file);
      }
    };
    input.click();
  }
  async processXMLFile(file) {
    var _a;
    try {
      new import_obsidian3.Notice(`Processing ${file.name}...`);
      const text = await file.text();
      const result = await (0, import_xml2js.parseStringPromise)(text);
      if (!result.XMLBIBLE || !result.XMLBIBLE.BIBLEBOOK) {
        throw new Error("Invalid XML file: missing XMLBIBLE or BIBLEBOOK elements");
      }
      const biblename = ((_a = result.XMLBIBLE.$) == null ? void 0 : _a.biblename) || file.name.replace(".xml", "");
      const translationName = biblename;
      const abbreviation = biblename.toUpperCase();
      const modal = new TranslationEditModal(this.app, translationName, abbreviation, "English", "Standard", [], async (name, abbr, language, category, processingRules) => {
        try {
          const existingTranslations = this.plugin.db.getTranslations();
          if (existingTranslations.some((t) => t.abbreviation === abbr)) {
            const confirmModal = new ConfirmModal(this.app, `Translation '${abbr}' already exists. Overwrite?`, async (confirmed) => {
              if (confirmed) {
                await this.plugin.db.removeTranslation(abbr);
                await this.importXMLBooks(result, name, abbr, file.name, language, category, processingRules);
              } else {
                new import_obsidian3.Notice("Import cancelled.");
              }
              this.display();
            });
            confirmModal.open();
            return;
          }
          await this.importXMLBooks(result, name, abbr, file.name, language, category, processingRules);
          this.display();
        } catch (error) {
          console.error("XML import error:", error);
          new import_obsidian3.Notice(`Failed to import ${file.name}: ${error.message}`);
        }
      }, false);
      modal.open();
    } catch (error) {
      console.error("XML import error:", error);
      new import_obsidian3.Notice(`Failed to import ${file.name}: ${error.message}`);
    }
  }
  async importXMLBooks(result, translationName, abbreviation, fileName, language = "English", category = "Standard", processingRules = []) {
    var _a, _b;
    try {
      const books = result.XMLBIBLE.BIBLEBOOK;
      if (!books || books.length === 0) {
        new import_obsidian3.Notice("No books found in XML. Import aborted.");
        console.error("No books found in XML:", result);
        return;
      }
      new import_obsidian3.Notice(`Starting import of ${translationName}...`);
      const translationId = await this.plugin.db.addTranslation(translationName, abbreviation, language, category, processingRules);
      let importedCount = 0;
      let bookCount = 0;
      const versesToAdd = [];
      for (const book of books) {
        if (!book || !book.$)
          continue;
        const bookName = book.$.bname || book.$.sname || "Unknown";
        const chapters = Array.isArray(book.CHAPTER) ? book.CHAPTER : [book.CHAPTER];
        for (const chapter of chapters) {
          if (!chapter || !chapter.$)
            continue;
          const chapterNum = parseInt(chapter.$.cnumber);
          if (isNaN(chapterNum))
            continue;
          const verses = Array.isArray(chapter.VERS) ? chapter.VERS : chapter.VERS ? [chapter.VERS] : [];
          for (const verse of verses) {
            if (!verse)
              continue;
            let verseText = "";
            let verseNum = 1;
            if (typeof verse === "string") {
              verseText = verse;
            } else if (verse._) {
              verseText = verse._;
            } else if (Array.isArray(verse)) {
              verseText = verse.join("");
            }
            if (verse.$ && verse.$.vnumber) {
              verseNum = parseInt(verse.$.vnumber);
            }
            if (verseText && verseText.trim()) {
              versesToAdd.push({
                translationId,
                book: bookName,
                chapter: chapterNum,
                verse: verseNum,
                text: verseText.trim()
              });
              importedCount++;
            }
          }
        }
        bookCount++;
        if (bookCount % 10 === 0) {
          new import_obsidian3.Notice(`Processed ${bookCount} books, ${importedCount} verses...`);
        }
      }
      console.log(`[BibleLink] Parsed ${importedCount} verses from XML for ${translationName}`);
      if (versesToAdd.length > 0) {
        new import_obsidian3.Notice(`Saving ${importedCount} verses to database...`);
        await this.plugin.db.addVersesBatch(versesToAdd);
        const translationExists = this.plugin.db.verifyTranslationExists(abbreviation);
        const translationStats = this.plugin.db.getTranslationStats(abbreviation);
        const allVerses = ((_b = (_a = this.plugin.db["data"]) == null ? void 0 : _a.verses) == null ? void 0 : _b.filter((v) => v.translation_id === translationId)) || [];
        console.log(`[BibleLink] Saved ${allVerses.length} verses for ${translationName} (should match ${importedCount})`);
        if (translationExists && translationStats && allVerses.length > 0) {
          new import_obsidian3.Notice(`\u2705 Successfully imported ${translationName} (${abbreviation}) with ${translationStats.verseCount} verses from ${translationStats.books.length} books`);
          console.log(`Bible import completed: ${translationName} (${abbreviation}) - ${translationStats.verseCount} verses from ${translationStats.books.length} books`);
        } else {
          new import_obsidian3.Notice(`\u274C Import failed: No verses saved for ${translationName}. Check the XML format and try again.`);
          console.error(`[BibleLink] Import failed: No verses saved for ${translationName}.`);
          await this.plugin.db.removeTranslation(abbreviation);
        }
      } else {
        new import_obsidian3.Notice("\u274C No verses were found in the XML file. Import aborted.");
        console.error("[BibleLink] No verses found in XML:", result);
        await this.plugin.db.removeTranslation(abbreviation);
      }
    } catch (error) {
      console.error("XML import error:", error);
      new import_obsidian3.Notice(`\u274C Failed to import ${fileName}: ${error.message}`);
      try {
        await this.plugin.db.removeTranslation(abbreviation);
      } catch (cleanupError) {
        console.error("Failed to cleanup after import error:", cleanupError);
      }
    }
  }
  async removeTranslation(abbreviation) {
    if (abbreviation === "ASV") {
      new import_obsidian3.Notice("Cannot remove ASV translation");
      return;
    }
    const success = await this.plugin.db.removeTranslation(abbreviation);
    if (success) {
      new import_obsidian3.Notice(`${abbreviation} translation removed`);
      if (this.plugin.settings.defaultTranslation === abbreviation) {
        this.plugin.settings.defaultTranslation = "ASV";
        await this.plugin.saveSettings();
      }
      this.display();
    } else {
      new import_obsidian3.Notice(`Failed to remove ${abbreviation}: translation not found`);
    }
  }
  confirmRemoveTranslation(abbreviation, name) {
    const modal = new ConfirmModal(this.app, `Remove translation '${name}' (${abbreviation})?`, async (confirmed) => {
      if (confirmed) {
        await this.removeTranslation(abbreviation);
      }
      this.display();
    });
    modal.open();
  }
  renderShortcutsSection(containerEl) {
    const shortcuts = this.plugin.settings.shortcuts;
    const filterContainer = containerEl.createDiv({ cls: "biblelink-filter-container" });
    const filterInput = filterContainer.createEl("input", {
      type: "text",
      placeholder: "Filter shortcuts...",
      cls: "biblelink-filter-input"
    });
    const table = containerEl.createEl("table", { cls: "biblelink-shortcut-table" });
    const thead = table.createEl("thead");
    const headerRow = thead.createEl("tr");
    let sortField = "key";
    let sortAsc = true;
    const createSortableHeader = (text, field) => {
      const th = headerRow.createEl("th", { text });
      th.style.cursor = "pointer";
      th.onclick = () => {
        if (sortField === field) {
          sortAsc = !sortAsc;
        } else {
          sortField = field;
          sortAsc = true;
        }
        renderShortcuts();
      };
    };
    createSortableHeader("Shortcut", "key");
    createSortableHeader("Reference", "reference");
    headerRow.createEl("th", { text: "Actions" });
    const tbody = table.createEl("tbody");
    const renderShortcuts = () => {
      tbody.empty();
      let shortcutEntries = Object.entries(shortcuts);
      const filterText = filterInput.value.toLowerCase();
      if (filterText) {
        shortcutEntries = shortcutEntries.filter(([key, ref]) => key.toLowerCase().includes(filterText) || ref.toLowerCase().includes(filterText));
      }
      shortcutEntries.sort(([keyA, refA], [keyB, refB]) => {
        const aVal = sortField === "key" ? keyA : refA;
        const bVal = sortField === "key" ? keyB : refB;
        return (sortAsc ? 1 : -1) * aVal.localeCompare(bVal);
      });
      shortcutEntries.forEach(([key, reference]) => {
        const row = tbody.createEl("tr");
        if (this._editingKey === key) {
          const keyCell = row.createEl("td");
          const keyInput = keyCell.createEl("input", {
            type: "text",
            value: key,
            cls: "biblelink-edit-input",
            placeholder: "Shortcut (e.g., jn316)"
          });
          const refCell = row.createEl("td");
          const refInput = refCell.createEl("input", {
            type: "text",
            value: reference,
            cls: "biblelink-edit-input",
            placeholder: "Reference (e.g., John 3:16)"
          });
          const actionCell = row.createEl("td");
          actionCell.createEl("button", { text: "Save" }).onclick = async () => {
            const newKey = keyInput.value.trim();
            const newRef = refInput.value.trim();
            if (!newKey || !newRef) {
              new import_obsidian3.Notice("Shortcut and reference required");
              return;
            }
            if (newKey !== key && shortcuts[newKey]) {
              new import_obsidian3.Notice("Shortcut key already exists");
              return;
            }
            if (!/^\w+\s+\d+:\d+$/.test(newRef) && !/^\w+\s+\d+:\d+(-\d+)?$/.test(newRef)) {
              new import_obsidian3.Notice("Reference must be in the format Book Chapter:Verse or Book Chapter:Verse-Verse");
              return;
            }
            delete shortcuts[key];
            shortcuts[newKey] = newRef;
            this._editingKey = null;
            await this.plugin.saveSettings();
            renderShortcuts();
            new import_obsidian3.Notice("Shortcut updated");
          };
          actionCell.createEl("button", { text: "Cancel" }).onclick = () => {
            this._editingKey = null;
            renderShortcuts();
          };
        } else {
          row.createEl("td", { text: key });
          row.createEl("td", { text: reference });
          const actionCell = row.createEl("td");
          actionCell.createEl("button", { text: "Edit" }).onclick = () => {
            this._editingKey = key;
            renderShortcuts();
          };
          actionCell.createEl("button", {
            text: "Remove",
            cls: "mod-warning"
          }).onclick = () => {
            const modal = new ConfirmModal(this.app, `Remove shortcut '${key}'?`, async (confirmed) => {
              if (confirmed) {
                delete shortcuts[key];
                await this.plugin.saveSettings();
                renderShortcuts();
              }
            });
            modal.open();
          };
        }
      });
      if (this._addingShortcut) {
        const row = tbody.createEl("tr");
        const keyInput = row.createEl("td").createEl("input", {
          type: "text",
          placeholder: "Shortcut (e.g., jn316)",
          cls: "biblelink-edit-input"
        });
        const refInput = row.createEl("td").createEl("input", {
          type: "text",
          placeholder: "Reference (e.g., John 3:16)",
          cls: "biblelink-edit-input"
        });
        const actionCell = row.createEl("td");
        actionCell.createEl("button", { text: "Add" }).onclick = async () => {
          const newKey = keyInput.value.trim();
          const newRef = refInput.value.trim();
          if (!newKey || !newRef) {
            new import_obsidian3.Notice("Shortcut and reference required");
            return;
          }
          if (shortcuts[newKey]) {
            new import_obsidian3.Notice("Shortcut key already exists");
            return;
          }
          if (!/^\w+\s+\d+:\d+$/.test(newRef) && !/^\w+\s+\d+:\d+(-\d+)?$/.test(newRef)) {
            new import_obsidian3.Notice("Reference must be in the format Book Chapter:Verse or Book Chapter:Verse-Verse");
            return;
          }
          shortcuts[newKey] = newRef;
          this._addingShortcut = false;
          await this.plugin.saveSettings();
          renderShortcuts();
          new import_obsidian3.Notice("Shortcut added");
        };
        actionCell.createEl("button", { text: "Cancel" }).onclick = () => {
          this._addingShortcut = false;
          renderShortcuts();
        };
      } else {
        const addRow = tbody.createEl("tr");
        const addCell = addRow.createEl("td", { attr: { colspan: "3" } });
        addCell.createEl("button", {
          text: "Add Shortcut",
          cls: "mod-cta"
        }).onclick = () => {
          this._addingShortcut = true;
          renderShortcuts();
        };
      }
    };
    renderShortcuts();
    filterInput.addEventListener("input", renderShortcuts);
    const css = `
            .biblelink-shortcut-table {
                width: 100%;
                border-collapse: collapse;
                margin-top: 10px;
            }
            .biblelink-shortcut-table th,
            .biblelink-shortcut-table td {
                padding: 8px;
                border: 1px solid var(--background-modifier-border);
                text-align: left;
            }
            .biblelink-shortcut-table th {
                background-color: var(--background-secondary);
            }
        `;
    const styleEl = document.head.createEl("style");
    styleEl.textContent = css;
  }
};
var ConfirmModal = class extends import_obsidian3.Modal {
  constructor(app, message, onResult) {
    super(app);
    this.message = message;
    this.onResult = onResult;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h3", { text: "Confirm" });
    contentEl.createEl("p", { text: this.message });
    const btnRow = contentEl.createDiv();
    btnRow.style.display = "flex";
    btnRow.style.gap = "10px";
    btnRow.createEl("button", { text: "Remove", cls: "mod-warning" }).onclick = () => {
      this.close();
      this.onResult(true);
    };
    btnRow.createEl("button", { text: "Cancel" }).onclick = () => {
      this.close();
      this.onResult(false);
    };
  }
  onClose() {
    this.contentEl.empty();
  }
};
var TranslationEditModal = class extends import_obsidian3.Modal {
  constructor(app, defaultName, defaultAbbr, defaultLanguage = "English", defaultCategory = "Standard", defaultProcessingRules = [], onSubmit, isEdit = false) {
    super(app);
    this.name = defaultName;
    this.abbreviation = defaultAbbr;
    this.language = defaultLanguage;
    this.category = defaultCategory;
    this.processingRules = [...defaultProcessingRules];
    this.onSubmit = onSubmit;
    this.isEdit = isEdit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: this.isEdit ? "Edit Translation" : "Add Translation" });
    new import_obsidian3.Setting(contentEl).setName("Translation Name").setDesc("Full name of the translation").addText((text) => text.setPlaceholder("e.g., American Standard Version").setValue(this.name).onChange((value) => {
      this.name = value;
    }));
    new import_obsidian3.Setting(contentEl).setName("Abbreviation").setDesc("Short abbreviation for the translation").addText((text) => text.setPlaceholder("e.g., ASV").setValue(this.abbreviation).onChange((value) => {
      this.abbreviation = value;
    }));
    new import_obsidian3.Setting(contentEl).setName("Language").setDesc("Language of the translation").addDropdown((dropdown) => {
      const languages = [
        "English",
        "Spanish",
        "French",
        "German",
        "Italian",
        "Portuguese",
        "Russian",
        "Chinese",
        "Japanese",
        "Korean",
        "Arabic",
        "Hebrew",
        "Greek",
        "Latin",
        "Swedish",
        "Norwegian",
        "Danish",
        "Dutch",
        "Polish",
        "Czech",
        "Slovak",
        "Hungarian",
        "Romanian",
        "Bulgarian",
        "Ukrainian",
        "Belarusian",
        "Serbian",
        "Croatian",
        "Slovenian",
        "Estonian",
        "Latvian",
        "Lithuanian",
        "Finnish",
        "Icelandic",
        "Turkish",
        "Persian",
        "Hindi",
        "Bengali",
        "Thai",
        "Vietnamese",
        "Indonesian",
        "Malay",
        "Filipino",
        "Other"
      ];
      languages.forEach((lang) => dropdown.addOption(lang, lang));
      dropdown.setValue(this.language);
      dropdown.onChange((value) => {
        this.language = value;
      });
    });
    new import_obsidian3.Setting(contentEl).setName("Category").setDesc("Category of the translation").addDropdown((dropdown) => {
      const categories = [
        "Standard",
        "Study",
        "Paraphrase",
        "Literal",
        "Dynamic",
        "Historical",
        "Catholic",
        "Orthodox",
        "Protestant",
        "Jewish",
        "Academic",
        "Children",
        "Other"
      ];
      categories.forEach((cat) => dropdown.addOption(cat, cat));
      dropdown.setValue(this.category);
      dropdown.onChange((value) => {
        this.category = value;
      });
    });
    contentEl.createEl("h3", { text: "Processing Rules" });
    contentEl.createEl("p", {
      text: "Add regex patterns to format verse text. Example: \\[\\w+\\] = <em>$&</em> to make bracketed text italic.",
      cls: "setting-item-description"
    });
    const rulesContainer = contentEl.createDiv({ cls: "processing-rules-container" });
    this.renderProcessingRules(rulesContainer);
    new import_obsidian3.Setting(contentEl).addButton((button) => button.setButtonText("Add Processing Rule").onClick(() => {
      this.processingRules.push({ regex: "", formatting: "", escape: false });
      this.renderProcessingRules(rulesContainer);
    }));
    const buttonContainer = contentEl.createDiv({ cls: "setting-item-control" });
    buttonContainer.createEl("button", {
      text: "Cancel",
      cls: "mod-warning"
    }).onclick = () => this.close();
    buttonContainer.createEl("button", {
      text: this.isEdit ? "Update" : "Add",
      cls: "mod-cta"
    }).onclick = () => {
      if (this.name.trim() && this.abbreviation.trim()) {
        this.onSubmit(this.name.trim(), this.abbreviation.trim(), this.language, this.category, this.processingRules);
        this.close();
      } else {
        new import_obsidian3.Notice("Please fill in all required fields");
      }
    };
  }
  renderProcessingRules(container) {
    container.empty();
    this.processingRules.forEach((rule, index) => {
      const ruleContainer = container.createDiv({ cls: "processing-rule-item" });
      new import_obsidian3.Setting(ruleContainer).setName("Regex Pattern").setDesc("Regular expression to match").addText((text) => text.setPlaceholder("e.g., \\[\\w+\\]").setValue(rule.regex).onChange((value) => {
        this.processingRules[index].regex = value;
      }));
      new import_obsidian3.Setting(ruleContainer).setName("Formatting").setDesc("Replacement text (use $& for matched text)").addText((text) => text.setPlaceholder("e.g., <em>$&</em>").setValue(rule.formatting).onChange((value) => {
        this.processingRules[index].formatting = value;
      }));
      new import_obsidian3.Setting(ruleContainer).setName("Escape special characters").setDesc("Escape [, ], <, >, & in the matched text for HTML output.").addToggle((toggle) => toggle.setValue(!!rule.escape).onChange((value) => {
        this.processingRules[index].escape = value;
      }));
      new import_obsidian3.Setting(ruleContainer).addButton((button) => button.setButtonText("Remove").setWarning().onClick(() => {
        this.processingRules.splice(index, 1);
        this.renderProcessingRules(container);
      }));
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/main.ts
var fs2 = __toModule(require("fs"));
var path2 = __toModule(require("path"));
var BOOK_ABBREVIATIONS = {
  "Genesis": "Gen",
  "Exodus": "Exo",
  "Leviticus": "Lev",
  "Numbers": "Num",
  "Deuteronomy": "Deu",
  "Joshua": "Jos",
  "Judges": "Jdg",
  "Ruth": "Rut",
  "1 Samuel": "1Sa",
  "2 Samuel": "2Sa",
  "1 Kings": "1Ki",
  "2 Kings": "2Ki",
  "1 Chronicles": "1Ch",
  "2 Chronicles": "2Ch",
  "Ezra": "Ezr",
  "Nehemiah": "Neh",
  "Esther": "Est",
  "Job": "Job",
  "Psalms": "Psa",
  "Proverbs": "Pro",
  "Ecclesiastes": "Ecc",
  "Song of Solomon": "Sng",
  "Isaiah": "Isa",
  "Jeremiah": "Jer",
  "Lamentations": "Lam",
  "Ezekiel": "Ezk",
  "Daniel": "Dan",
  "Hosea": "Hos",
  "Joel": "Jol",
  "Amos": "Amo",
  "Obadiah": "Oba",
  "Jonah": "Jon",
  "Micah": "Mic",
  "Nahum": "Nah",
  "Habakkuk": "Hab",
  "Zephaniah": "Zep",
  "Haggai": "Hag",
  "Zechariah": "Zec",
  "Malachi": "Mal",
  "Matthew": "Mat",
  "Mark": "Mrk",
  "Luke": "Luk",
  "John": "Jhn",
  "Acts": "Act",
  "Romans": "Rom",
  "1 Corinthians": "1Co",
  "2 Corinthians": "2Co",
  "Galatians": "Gal",
  "Ephesians": "Eph",
  "Philippians": "Php",
  "Colossians": "Col",
  "1 Thessalonians": "1Th",
  "2 Thessalonians": "2Th",
  "1 Timothy": "1Ti",
  "2 Timothy": "2Ti",
  "Titus": "Tit",
  "Philemon": "Phm",
  "Hebrews": "Heb",
  "James": "Jas",
  "1 Peter": "1Pe",
  "2 Peter": "2Pe",
  "1 John": "1Jn",
  "2 John": "2Jn",
  "3 John": "3Jn",
  "Jude": "Jud",
  "Revelation": "Rev"
};
var BibleLinkPlugin = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    this.isFirstLoad = true;
  }
  async onload() {
    await this.loadSettings();
    this.db = new BibleDatabase(this);
    if (this.isFirstLoad) {
      await this.db.initialize();
      this.isFirstLoad = false;
      new import_obsidian4.Notice('Welcome to BibleLink! ASV Bible is ready. Use "Insert Bible Reference" command to get started.');
    } else {
      await this.db.initialize();
    }
    window.BibleLinkPlugin = this;
    window.BibleLinkAPI = {
      getAllVerses: () => this.getAllVersesWithMetadata(),
      queryVerses: (book, chapter, translation) => this.queryVerses(book, chapter, translation),
      getTranslations: () => this.db.getTranslations(),
      getBooks: () => this.db.getBooks(),
      getChaptersForBook: (book, translation) => this.db.getChaptersForBook(book, translation),
      getVersesForChapter: (book, chapter, translation) => this.db.getVersesForChapter(book, chapter, translation),
      getVerse: (book, chapter, verse, translation) => this.db.getVerse(book, chapter, verse, translation),
      plugin: this
    };
    const parseReference = (ref) => {
      const match = ref.match(/^(.+?)\s+(\d+)(?::(\d+))?$/);
      if (!match)
        return null;
      const [, book, chapter, verse] = match;
      return {
        book: book.trim(),
        chapter: parseInt(chapter),
        verse: verse ? parseInt(verse) : void 0
      };
    };
    this.registerMarkdownCodeBlockProcessor(this.settings.codeBlockLanguage, (source, el, ctx) => {
      this.processCodeBlock(source, el, ctx);
    });
    this.addCommand({
      id: "insert-bible-reference",
      name: "Insert Bible Reference",
      editorCallback: (editor) => {
        new BibleSelectorModal(this.app, this, (reference, translation, outputType, options) => {
          this.insertBibleReference(editor, reference, translation, outputType, options);
        }).open();
      }
    });
    if (this.settings.enableShortcuts) {
      this.registerShortcutCommands();
    }
    this.addSettingTab(new BibleLinkSettingTab(this.app, this));
    this.registerDataviewSource();
    this.addStyles();
    this.updateStyles();
    this.testSettingsPersistence();
    console.log("BibleLink plugin loaded");
  }
  testSettingsPersistence() {
    console.log("[BibleLink] [testSettingsPersistence] Current settings:", {
      defaultTranslation: this.settings.defaultTranslation,
      outputType: this.settings.outputType,
      modalOutputType: this.settings.modalOutputType,
      modalOptions: this.settings.modalOptions,
      codeBlockBackgroundColor: this.settings.codeBlockBackgroundColor,
      codeBlockTextColor: this.settings.codeBlockTextColor
    });
    const settingsPath = path2.join(this.app.vault.adapter.basePath, ".obsidian", "plugins", "obsidian-biblelink", "data", "settings.json");
    if (fs2.existsSync(settingsPath)) {
      const content = fs2.readFileSync(settingsPath, "utf8");
      console.log("[BibleLink] [testSettingsPersistence] Settings file exists and contains:", content.slice(0, 500));
    } else {
      console.log("[BibleLink] [testSettingsPersistence] Settings file does not exist yet");
    }
  }
  async onunload() {
    if (this.db) {
      await this.db.close();
    }
    if (window.BibleLinkAPI) {
      delete window.BibleLinkAPI;
    }
    if (window.BibleLinkPlugin) {
      delete window.BibleLinkPlugin;
    }
    console.log("BibleLink plugin unloaded");
  }
  async loadSettings() {
    try {
      const settingsPath = path2.join(this.app.vault.adapter.basePath, ".obsidian", "plugins", "obsidian-biblelink", "data", "settings.json");
      console.log(`[BibleLink] [loadSettings] Loading settings from: ${settingsPath}`);
      if (fs2.existsSync(settingsPath)) {
        const content = fs2.readFileSync(settingsPath, "utf8");
        console.log(`[BibleLink] [loadSettings] Settings file found. First 200 chars:`, content.slice(0, 200));
        const savedSettings = JSON.parse(content);
        this.settings = Object.assign({}, DEFAULT_SETTINGS, savedSettings);
        console.log(`[BibleLink] [loadSettings] Loaded settings successfully`);
      } else {
        console.log("[BibleLink] [loadSettings] No settings file found, using defaults");
        this.settings = Object.assign({}, DEFAULT_SETTINGS);
        await this.saveSettings();
        console.log("[BibleLink] [loadSettings] Created default settings file");
      }
    } catch (error) {
      console.error("[BibleLink] [loadSettings] Error loading settings:", error);
      this.settings = Object.assign({}, DEFAULT_SETTINGS);
    }
  }
  async saveSettings() {
    try {
      const dataDir = path2.join(this.app.vault.adapter.basePath, ".obsidian", "plugins", "obsidian-biblelink", "data");
      if (!fs2.existsSync(dataDir)) {
        fs2.mkdirSync(dataDir, { recursive: true });
      }
      const settingsPath = path2.join(dataDir, "settings.json");
      const content = JSON.stringify(this.settings, null, 2);
      console.log(`[BibleLink] [saveSettings] Saving settings to: ${settingsPath}`);
      console.log(`[BibleLink] [saveSettings] Settings (first 200 chars):`, content.slice(0, 200));
      fs2.writeFileSync(settingsPath, content, "utf8");
      console.log(`[BibleLink] [saveSettings] Settings saved successfully`);
      this.updateStyles();
    } catch (error) {
      console.error("[BibleLink] [saveSettings] Error saving settings:", error);
      new import_obsidian4.Notice("Failed to save settings");
    }
  }
  addStyles() {
    this.updateStyles();
  }
  updateStyles() {
    const existingStyle = document.getElementById("biblelink-styles");
    if (existingStyle) {
      existingStyle.remove();
    }
    const style = document.createElement("style");
    style.id = "biblelink-styles";
    style.textContent = `
            .bible-reference {
                color: ${this.settings.codeBlockTextColor};
                background-color: ${this.settings.codeBlockBackgroundColor};
                padding: 2px 6px;
                border-radius: 4px;
                display: inline-block;
                margin: 0 2px;
            }
            
            .bible-reference.simple {
                font-weight: normal;
                background: none;
                padding: 0;
                color: inherit;
            }
            
            .bible-reference.detailed {
                font-weight: 500;
            }
            
            .bible-reference.custom {
                font-style: italic;
            }

            .bible-verse-container {
                margin: 1em 0;
                line-height: 1.5;
            }

            .bible-verse-reference {
                font-weight: 500;
                color: var(--text-muted);
            }

            .bible-verse-text {
                margin-top: 0.5em;
            }

            .bible-verse-text sup {
                color: ${this.settings.codeBlockVerseNumberColor};
                font-size: 0.8em;
                font-weight: 500;
                vertical-align: super;
            }

            .red-letter-text {
                color: var(--text-red);
            }

            .chapter-number {
                font-weight: bold;
                color: var(--text-muted);
                margin-top: 1em;
                margin-bottom: 0.5em;
            }

            .bible-verse-link {
                margin-top: 1em;
                text-align: right;
            }

            .bible-verse-link a {
                color: var(--text-accent);
                font-size: 0.9em;
                text-decoration: none;
            }

            .bible-verse-link a:hover {
                text-decoration: underline;
            }

            /* BibleLink chapter/verse grid styles */
            .biblelink-chapter-grid, .biblelink-verse-grid {
                display: flex;
                flex-wrap: wrap;
                gap: 6px;
                margin-bottom: 8px;
            }
            .biblelink-chapter-btn, .biblelink-verse-btn {
                min-width: 32px;
                min-height: 32px;
                border-radius: 4px;
                border: 1px solid var(--background-modifier-border);
                background: var(--background-secondary);
                cursor: pointer;
                font-size: 1em;
                transition: background 0.2s, color 0.2s;
            }
            .biblelink-chapter-btn.selected, .biblelink-verse-btn.selected {
                background: var(--interactive-accent);
                color: var(--text-on-accent);
                font-weight: bold;
            }
        `;
    document.head.appendChild(style);
  }
  processCodeBlock(source, el, ctx) {
    el.style.backgroundColor = this.settings.codeBlockBackgroundColor;
    el.style.color = this.settings.codeBlockTextColor;
    const lines = source.trim().split("\n");
    if (lines.length === 0)
      return;
    const firstLine = lines[0].trim();
    const parts = firstLine.split(" ").filter((p) => p.length > 0);
    const options = {
      verse: false,
      chapter: false,
      redText: false,
      link: false
    };
    let translationIndex = 0;
    let referenceStartIndex = 1;
    for (let i = 1; i < parts.length; i++) {
      const part = parts[i].toLowerCase();
      if (["verse", "chapter", "red-text", "link"].includes(part)) {
        switch (part) {
          case "verse":
            options.verse = true;
            break;
          case "chapter":
            options.chapter = true;
            break;
          case "red-text":
            options.redText = true;
            break;
          case "link":
            options.link = true;
            break;
        }
        translationIndex = i + 1;
      } else {
        break;
      }
    }
    const lastPart = parts[parts.length - 1];
    let referenceEndIndex = parts.length;
    if (lastPart.startsWith("[") && lastPart.endsWith("]")) {
      const optionsStr = lastPart.slice(1, -1);
      const optionsList = optionsStr.split(/[,|]/).map((o) => o.trim()).filter((o) => o.length > 0);
      options.verse = options.verse || optionsList.includes("verse");
      options.chapter = options.chapter || optionsList.includes("chapter");
      options.redText = options.redText || optionsList.includes("red-text");
      options.link = options.link || optionsList.includes("link");
      referenceEndIndex--;
    }
    if (translationIndex >= referenceEndIndex) {
      el.createSpan({ text: "Invalid format. Use: ```bible [option1,option2] TRANSLATION REFERENCE``` or ```bible TRANSLATION REFERENCE [option1,option2]```" });
      return;
    }
    const translation = parts[translationIndex];
    const referenceText = parts.slice(translationIndex + 1, referenceEndIndex).join(" ");
    const crossRefMatch = referenceText.match(/^(.+?)\s+(\d+):(\d+)-(.+?)\s+(\d+):(\d+)$/);
    let verses = [];
    if (crossRefMatch) {
      const [, startBook, startChapter, startVerse, endBook, endChapter, endVerse] = crossRefMatch;
      const startChapterNum = parseInt(startChapter);
      const startVerseNum = parseInt(startVerse);
      const endChapterNum = parseInt(endChapter);
      const endVerseNum = parseInt(endVerse);
      if (startBook !== endBook) {
        el.createSpan({ text: "Cross-book references are not supported yet." });
        return;
      }
      for (let chapter = startChapterNum; chapter <= endChapterNum; chapter++) {
        const start = chapter === startChapterNum ? startVerseNum : 1;
        const end = chapter === endChapterNum ? endVerseNum : 999;
        for (let verse = start; verse <= end; verse++) {
          const verseData = this.db.getVerse(startBook, chapter, verse, translation);
          if (verseData) {
            verses.push({ chapter, verse, text: verseData.text });
          }
        }
      }
      if (verses.length === 0) {
        el.createSpan({ text: `Invalid reference: ${referenceText} in ${translation}` });
        return;
      }
      const container = el.createDiv({
        cls: `bible-verse-container${options.redText ? " red-letter" : ""}${options.chapter ? " show-chapter" : ""}${options.verse ? " show-verse" : ""}`
      });
      const ref = `${startBook} ${startChapterNum}:${startVerseNum}-${endChapterNum}:${endVerseNum} (${translation})`;
      container.createSpan({ text: ref + ": ", cls: "bible-verse-reference" });
      const verseContainer = container.createDiv({ cls: "bible-verse-text" });
      let lastChapter = -1;
      verses.forEach((verse) => {
        if (options.chapter && verse.chapter !== lastChapter) {
          verseContainer.createEl("h4", {
            text: `Chapter ${verse.chapter}`,
            cls: "chapter-number"
          });
          lastChapter = verse.chapter;
        }
        if (options.verse) {
          const sup = verseContainer.createEl("sup", { text: verse.verse.toString() });
          sup.style.marginRight = "0.3em";
        }
        let processedText = this.db.applyProcessingRules(verse.text, translation);
        if (options.redText) {
          const words = processedText.split(" ");
          words.forEach((word, i) => {
            const isJesusWord = this.isJesusWord(word);
            verseContainer.createSpan({
              text: word + (i < words.length - 1 ? " " : ""),
              cls: isJesusWord ? "red-letter-text" : ""
            });
          });
        } else {
          const textSpan = verseContainer.createSpan();
          textSpan.innerHTML = processedText + " ";
        }
      });
      if (options.link) {
        const linkContainer = container.createDiv({ cls: "bible-verse-link" });
        const linkText = `${startBook} ${startChapterNum}:${startVerseNum}${endVerseNum !== startVerseNum ? "-" + endVerseNum : ""}`;
        const linkUrl = this.generateBibleGatewayUrl(linkText, translation);
        const link = linkContainer.createEl("a", {
          text: `[@${linkUrl}]`,
          href: linkUrl
        });
        link.addClass("external-link");
      }
    } else {
      const match = referenceText.match(/^(.+?)\s+(\d+)(?::(\d+)(?:-(\d+))?)?$/);
      if (!match) {
        el.createSpan({ text: `Invalid reference format: ${referenceText}` });
        return;
      }
      const [, book, chapter, startVerse, endVerse] = match;
      const startChapterNum = parseInt(chapter);
      const startVerseNum = startVerse ? parseInt(startVerse) : 1;
      const endVerseNum = endVerse ? parseInt(endVerse) : startVerseNum;
      for (let v = startVerseNum; v <= endVerseNum; v++) {
        const verseData = this.db.getVerse(book, startChapterNum, v, translation);
        if (verseData) {
          verses.push({ chapter: startChapterNum, verse: v, text: verseData.text });
        }
      }
      if (verses.length === 0) {
        el.createSpan({ text: `Invalid reference: ${book} ${startChapterNum}:${startVerseNum}${endVerseNum !== startVerseNum ? "-" + endVerseNum : ""} in ${translation}` });
        return;
      }
      const container = el.createDiv({
        cls: `bible-verse-container${options.redText ? " red-letter" : ""}${options.chapter ? " show-chapter" : ""}${options.verse ? " show-verse" : ""}`
      });
      const ref = `${book} ${startChapterNum}:${startVerseNum}${endVerseNum !== startVerseNum ? "-" + endVerseNum : ""} (${translation})`;
      container.createSpan({ text: ref + ": ", cls: "bible-verse-reference" });
      const verseContainer = container.createDiv({ cls: "bible-verse-text" });
      let lastChapter = -1;
      verses.forEach((verse) => {
        if (options.chapter && verse.chapter !== lastChapter) {
          const chapterNum = verseContainer.createEl("strong", {
            text: verse.chapter.toString(),
            cls: "chapter-number"
          });
          chapterNum.style.marginRight = "0.5em";
          lastChapter = verse.chapter;
        }
        if (options.verse || verses.length > 1) {
          const sup = verseContainer.createEl("sup", { text: verse.verse.toString() });
          sup.style.marginRight = "0.3em";
        }
        let processedText = this.db.applyProcessingRules(verse.text, translation);
        if (options.redText) {
          const words = processedText.split(" ");
          words.forEach((word, i) => {
            const isJesusWord = this.isJesusWord(word);
            verseContainer.createSpan({
              text: word + (i < words.length - 1 ? " " : ""),
              cls: isJesusWord ? "red-letter-text" : ""
            });
          });
        } else {
          const textSpan = verseContainer.createSpan();
          textSpan.innerHTML = processedText + " ";
        }
      });
      if (options.link) {
        const linkContainer = container.createDiv({ cls: "bible-verse-link" });
        const linkText = `${book} ${startChapterNum}:${startVerseNum}${endVerseNum !== startVerseNum ? "-" + endVerseNum : ""}`;
        const linkUrl = this.generateBibleGatewayUrl(linkText, translation);
        const link = linkContainer.createEl("a", {
          text: `[@${linkUrl}]`,
          href: linkUrl
        });
        link.addClass("external-link");
      }
    }
  }
  registerShortcutCommands() {
    Object.entries(this.settings.shortcuts).forEach(([shortcut, reference]) => {
      this.addCommand({
        id: `bible-shortcut-${shortcut}`,
        name: `Insert ${reference} (${shortcut})`,
        editorCallback: (editor) => {
          this.insertShortcutReference(editor, reference);
        }
      });
    });
  }
  insertShortcutReference(editor, reference) {
    const match = reference.match(/^(\w+)\s+(\d+):(\d+)$/);
    if (!match) {
      new import_obsidian4.Notice(`Invalid reference format: ${reference}`);
      return;
    }
    const [, book, chapter, verse] = match;
    const chapterNum = parseInt(chapter);
    const verseNum = parseInt(verse);
    const verseData = this.db.getVerse(book, chapterNum, verseNum, this.settings.defaultTranslation);
    if (!verseData) {
      new import_obsidian4.Notice(`Verse not found: ${reference} in ${this.settings.defaultTranslation}`);
      return;
    }
    this.insertBibleReference(editor, reference, this.settings.defaultTranslation, this.settings.outputType, []);
  }
  insertBibleReference(editor, reference, translation, outputType, options) {
    const match = reference.match(/^(.+?)\s+(\d+)(?::(\d+)(?:-(\d+))?)?$/);
    if (!match) {
      new import_obsidian4.Notice(`Invalid reference format: ${reference}`);
      return;
    }
    const [, book, chapter, startVerse, endVerse] = match;
    const chapterNum = parseInt(chapter);
    const startVerseNum = startVerse ? parseInt(startVerse) : 1;
    const endVerseNum = endVerse ? parseInt(endVerse) : startVerse ? startVerseNum : null;
    let verses = [];
    const verseRange = endVerseNum ? Array.from({ length: endVerseNum - startVerseNum + 1 }, (_, i) => startVerseNum + i) : [startVerseNum];
    for (const verse of verseRange) {
      const verseData = this.db.getVerse(book, chapterNum, verse, translation);
      if (verseData) {
        verses.push({ verse, text: verseData.text });
      }
    }
    if (verses.length === 0) {
      new import_obsidian4.Notice(`Invalid reference: ${reference} in ${translation}`);
      return;
    }
    let text;
    if (outputType === "text") {
      const verseTexts = verses.map((v) => {
        return verses.length > 1 ? `${v.verse} ${v.text}` : v.text;
      });
      text = `${reference} (${translation}): ${verseTexts.join(" ")}`;
    } else if (outputType === "link") {
      text = `[${reference} (${translation})](${this.generateBibleGatewayUrl(reference, translation)})`;
    } else {
      const optionsStr = options.length > 0 ? ` [${options.join("|")}]` : "";
      text = `\`\`\`${this.settings.codeBlockLanguage}
${translation} ${reference}${optionsStr}
${verses.map((v) => v.text).join(" ")}
\`\`\``;
    }
    editor.replaceSelection(text);
    this.createVerseNote(book, chapterNum, startVerseNum, translation);
  }
  formatReference(book, chapter, verse, translation) {
    let formattedBook = book;
    if (this.settings.showBookAbbr && BOOK_ABBREVIATIONS[book]) {
      formattedBook = BOOK_ABBREVIATIONS[book];
    }
    return this.settings.showTranslationAbbr ? `${formattedBook} ${chapter}:${verse} ${translation}` : `${formattedBook} ${chapter}:${verse}`;
  }
  async createVerseNote(book, chapter, verse, translation) {
    try {
      const verseData = this.db.getVerse(book, chapter, verse, translation);
      if (!verseData)
        return;
      const notePath = `Bible/${book}/${chapter}/${verse}.md`;
      const existingFile = this.app.vault.getAbstractFileByPath(notePath);
      if (existingFile)
        return;
      const dirPath = `Bible/${book}/${chapter}`;
      const dirExists = this.app.vault.getAbstractFileByPath(dirPath);
      if (!dirExists) {
        await this.createDirectoryRecursive(dirPath);
      }
      const translationInfo = this.getTranslationInfo(translation);
      const reference = this.formatReference(book, chapter, verse, translation);
      const content = `---
book: ${book}
chapter: ${chapter}
verse: ${verse}
translation: ${translation}
text: "${verseData.text.replace(/"/g, '\\"')}"
reference: "${reference}"
language: "${translationInfo.language}"
category: "${translationInfo.category}"
translation_name: "${translationInfo.name}"
created: ${new Date().toISOString()}
---

# ${reference}

${verseData.text}

*Translation: ${translationInfo.name} (${translation})*

## Metadata

- **Book**: ${book}
- **Chapter**: ${chapter}
- **Verse**: ${verse}
- **Translation**: ${translation}
- **Language**: ${translationInfo.language}
- **Category**: ${translationInfo.category}
- **Reference**: ${reference}

## Related Verses

\`\`\`dataview
LIST reference, text
FROM "Bible"
WHERE book = "${book}" AND chapter = ${chapter}
SORT verse
\`\`\`

## Cross-References

\`\`\`dataview
LIST reference, text
FROM "Bible"
WHERE contains(text, "${verseData.text.split(" ").slice(0, 3).join(" ")}")
AND file.name != this.file.name
LIMIT 5
\`\`\`
`;
      await this.app.vault.create(notePath, content);
    } catch (error) {
      console.error("Error creating verse note:", error);
    }
  }
  getTranslationInfo(abbreviation) {
    const translation = this.db.getTranslations().find((t) => t.abbreviation === abbreviation);
    if (translation) {
      const knownTranslation = this.getKnownTranslation(abbreviation);
      return {
        name: translation.name,
        language: (knownTranslation == null ? void 0 : knownTranslation.language) || "unknown",
        category: (knownTranslation == null ? void 0 : knownTranslation.category) || "Unknown"
      };
    }
    return {
      name: abbreviation,
      language: "unknown",
      category: "Unknown"
    };
  }
  getKnownTranslation(abbreviation) {
    const knownTranslations = {
      "ASV": { name: "American Standard Version (1901)", language: "en", category: "English" },
      "KJV": { name: "King James Version", language: "en", category: "English" },
      "WEB": { name: "World English Bible", language: "en", category: "English" },
      "YLT": { name: "Young's Literal Translation (1898)", language: "en", category: "English" },
      "BBE": { name: "Bible in Basic English (1949/1964)", language: "en", category: "English" },
      "BSB": { name: "Berean Standard Bible", language: "en", category: "English" },
      "CPDV": { name: "Catholic Public Domain Version", language: "en", category: "English" },
      "SpaRV": { name: "La Santa Biblia Reina-Valera (1909)", language: "es", category: "Spanish" },
      "Vulgate": { name: "Latin Vulgate", language: "la", category: "Latin" },
      "Byz": { name: "Byzantine Textform (Greek)", language: "grc", category: "Greek" },
      "WLC": { name: "Westminster Leningrad Codex", language: "hbo", category: "Hebrew" }
    };
    return knownTranslations[abbreviation] || null;
  }
  async createDirectoryRecursive(dirPath) {
    const parts = dirPath.split("/");
    let currentPath = "";
    for (const part of parts) {
      currentPath = currentPath ? `${currentPath}/${part}` : part;
      const exists = this.app.vault.getAbstractFileByPath(currentPath);
      if (!exists) {
        try {
          await this.app.vault.createFolder(currentPath);
        } catch (error) {
        }
      }
    }
  }
  registerDataviewSource() {
    const dataviewPlugin = this.app.plugins.plugins["dataview"];
    if (!dataviewPlugin) {
      console.log("[BibleLink] Dataview plugin not found, skipping Dataview integration");
      return;
    }
    try {
      console.log("[BibleLink] Dataview plugin found, exposing API for DataviewJS access");
      console.log("[BibleLink] Use BibleLinkAPI or BibleLinkPlugin in DataviewJS queries");
    } catch (error) {
      console.error("[BibleLink] Failed to initialize Dataview integration:", error);
    }
  }
  handleDataviewQuery(query) {
    try {
      console.log("[BibleLink] Processing Dataview query:", query);
      const parsedQuery = this.parseDataviewQuery(query);
      console.log("[BibleLink] Parsed query:", parsedQuery);
      let results = this.getAllVersesWithMetadata();
      if (parsedQuery.where) {
        results = this.applyWhereConditions(results, parsedQuery.where);
      }
      if (parsedQuery.sort) {
        results = this.applySort(results, parsedQuery.sort);
      }
      if (parsedQuery.limit) {
        results = results.slice(0, parsedQuery.limit);
      }
      console.log(`[BibleLink] Query returned ${results.length} results`);
      return results;
    } catch (error) {
      console.error("[BibleLink] Dataview query error:", error);
      return [];
    }
  }
  parseDataviewQuery(query) {
    const result = {};
    const whereMatch = query.match(/WHERE\s+(.+?)(?:\s+SORT|\s+LIMIT|$)/i);
    if (whereMatch) {
      result.where = this.parseWhereConditions(whereMatch[1]);
    }
    const sortMatch = query.match(/SORT\s+(.+?)(?:\s+LIMIT|$)/i);
    if (sortMatch) {
      result.sort = this.parseSortConditions(sortMatch[1]);
    }
    const limitMatch = query.match(/LIMIT\s+(\d+)/i);
    if (limitMatch) {
      result.limit = parseInt(limitMatch[1]);
    }
    return result;
  }
  parseWhereConditions(conditions) {
    const parsedConditions = [];
    const andParts = conditions.split(/\s+AND\s+/i);
    for (const part of andParts) {
      const eqMatch = part.match(/(\w+)\s*=\s*"([^"]+)"/i);
      if (eqMatch) {
        parsedConditions.push({
          type: "equals",
          field: eqMatch[1].toLowerCase(),
          value: eqMatch[2]
        });
        continue;
      }
      const numMatch = part.match(/(\w+)\s*=\s*(\d+)/i);
      if (numMatch) {
        parsedConditions.push({
          type: "equals",
          field: numMatch[1].toLowerCase(),
          value: parseInt(numMatch[2])
        });
        continue;
      }
      const containsMatch = part.match(/contains\((\w+),\s*"([^"]+)"\)/i);
      if (containsMatch) {
        parsedConditions.push({
          type: "contains",
          field: containsMatch[1].toLowerCase(),
          value: containsMatch[2]
        });
        continue;
      }
      const gtMatch = part.match(/(\w+)\s*>\s*(\d+)/i);
      if (gtMatch) {
        parsedConditions.push({
          type: "greater_than",
          field: gtMatch[1].toLowerCase(),
          value: parseInt(gtMatch[2])
        });
        continue;
      }
      const ltMatch = part.match(/(\w+)\s*<\s*(\d+)/i);
      if (ltMatch) {
        parsedConditions.push({
          type: "less_than",
          field: ltMatch[1].toLowerCase(),
          value: parseInt(ltMatch[2])
        });
        continue;
      }
    }
    return parsedConditions;
  }
  parseSortConditions(sortClause) {
    const sorts = [];
    const parts = sortClause.split(",").map((p) => p.trim());
    for (const part of parts) {
      const descMatch = part.match(/(\w+)\s+DESC/i);
      if (descMatch) {
        sorts.push({ field: descMatch[1].toLowerCase(), direction: "desc" });
        continue;
      }
      const ascMatch = part.match(/(\w+)\s+ASC/i);
      if (ascMatch) {
        sorts.push({ field: ascMatch[1].toLowerCase(), direction: "asc" });
        continue;
      }
      const fieldMatch = part.match(/(\w+)/i);
      if (fieldMatch) {
        sorts.push({ field: fieldMatch[1].toLowerCase(), direction: "asc" });
      }
    }
    return sorts;
  }
  getAllVersesWithMetadata() {
    const results = [];
    for (const translation of this.db.getTranslations()) {
      for (const book of this.db.getBooks()) {
        const chapters = this.db.getChaptersForBook(book, translation.abbreviation);
        for (const chapter of chapters) {
          const verses = this.db.getVersesForChapter(book, chapter, translation.abbreviation);
          for (const verseNum of verses) {
            const verseData = this.db.getVerse(book, chapter, verseNum, translation.abbreviation);
            if (verseData) {
              const text = verseData.text;
              const wordCount = text.split(/\s+/).length;
              const charCount = text.length;
              results.push({
                book: verseData.book,
                chapter: verseData.chapter,
                verse: verseData.verse,
                text,
                translation: translation.abbreviation,
                translation_name: translation.name,
                reference: `${verseData.book} ${verseData.chapter}:${verseData.verse}`,
                word_count: wordCount,
                char_count: charCount,
                is_jesus_word: this.isJesusWord(text),
                has_red_letter: this.hasRedLetterWords(text),
                testament: this.getTestament(verseData.book),
                book_category: this.getBookCategory(verseData.book)
              });
            }
          }
        }
      }
    }
    return results;
  }
  applyWhereConditions(verses, conditions) {
    return verses.filter((verse) => {
      return conditions.every((condition) => {
        const fieldValue = verse[condition.field];
        switch (condition.type) {
          case "equals":
            return fieldValue === condition.value;
          case "contains":
            return typeof fieldValue === "string" && fieldValue.toLowerCase().includes(condition.value.toLowerCase());
          case "greater_than":
            return typeof fieldValue === "number" && fieldValue > condition.value;
          case "less_than":
            return typeof fieldValue === "number" && fieldValue < condition.value;
          default:
            return true;
        }
      });
    });
  }
  applySort(verses, sorts) {
    return [...verses].sort((a, b) => {
      for (const sort of sorts) {
        const aVal = a[sort.field];
        const bVal = b[sort.field];
        let comparison = 0;
        if (typeof aVal === "string" && typeof bVal === "string") {
          comparison = aVal.localeCompare(bVal);
        } else if (typeof aVal === "number" && typeof bVal === "number") {
          comparison = aVal - bVal;
        } else {
          comparison = String(aVal).localeCompare(String(bVal));
        }
        if (comparison !== 0) {
          return sort.direction === "desc" ? -comparison : comparison;
        }
      }
      return 0;
    });
  }
  getTestament(book) {
    const oldTestamentBooks = [
      "Genesis",
      "Exodus",
      "Leviticus",
      "Numbers",
      "Deuteronomy",
      "Joshua",
      "Judges",
      "Ruth",
      "1 Samuel",
      "2 Samuel",
      "1 Kings",
      "2 Kings",
      "1 Chronicles",
      "2 Chronicles",
      "Ezra",
      "Nehemiah",
      "Esther",
      "Job",
      "Psalms",
      "Proverbs",
      "Ecclesiastes",
      "Song of Solomon",
      "Isaiah",
      "Jeremiah",
      "Lamentations",
      "Ezekiel",
      "Daniel",
      "Hosea",
      "Joel",
      "Amos",
      "Obadiah",
      "Jonah",
      "Micah",
      "Nahum",
      "Habakkuk",
      "Zephaniah",
      "Haggai",
      "Zechariah",
      "Malachi"
    ];
    return oldTestamentBooks.includes(book) ? "Old Testament" : "New Testament";
  }
  getBookCategory(book) {
    const categories = {
      "Genesis": "Law",
      "Exodus": "Law",
      "Leviticus": "Law",
      "Numbers": "Law",
      "Deuteronomy": "Law",
      "Joshua": "Historical",
      "Judges": "Historical",
      "Ruth": "Historical",
      "1 Samuel": "Historical",
      "2 Samuel": "Historical",
      "1 Kings": "Historical",
      "2 Kings": "Historical",
      "1 Chronicles": "Historical",
      "2 Chronicles": "Historical",
      "Ezra": "Historical",
      "Nehemiah": "Historical",
      "Esther": "Historical",
      "Job": "Wisdom",
      "Psalms": "Wisdom",
      "Proverbs": "Wisdom",
      "Ecclesiastes": "Wisdom",
      "Song of Solomon": "Wisdom",
      "Isaiah": "Prophetic",
      "Jeremiah": "Prophetic",
      "Lamentations": "Prophetic",
      "Ezekiel": "Prophetic",
      "Daniel": "Prophetic",
      "Hosea": "Prophetic",
      "Joel": "Prophetic",
      "Amos": "Prophetic",
      "Obadiah": "Prophetic",
      "Jonah": "Prophetic",
      "Micah": "Prophetic",
      "Nahum": "Prophetic",
      "Habakkuk": "Prophetic",
      "Zephaniah": "Prophetic",
      "Haggai": "Prophetic",
      "Zechariah": "Prophetic",
      "Malachi": "Prophetic",
      "Matthew": "Gospel",
      "Mark": "Gospel",
      "Luke": "Gospel",
      "John": "Gospel",
      "Acts": "Historical",
      "Romans": "Epistle",
      "1 Corinthians": "Epistle",
      "2 Corinthians": "Epistle",
      "Galatians": "Epistle",
      "Ephesians": "Epistle",
      "Philippians": "Epistle",
      "Colossians": "Epistle",
      "1 Thessalonians": "Epistle",
      "2 Thessalonians": "Epistle",
      "1 Timothy": "Epistle",
      "2 Timothy": "Epistle",
      "Titus": "Epistle",
      "Philemon": "Epistle",
      "Hebrews": "Epistle",
      "James": "Epistle",
      "1 Peter": "Epistle",
      "2 Peter": "Epistle",
      "1 John": "Epistle",
      "2 John": "Epistle",
      "3 John": "Epistle",
      "Jude": "Epistle",
      "Revelation": "Apocalyptic"
    };
    return categories[book] || "Unknown";
  }
  hasRedLetterWords(text) {
    const jesusIndicators = [
      "I am",
      "verily",
      "truly",
      "amen",
      "father",
      "kingdom",
      "heaven",
      "parable",
      "disciple",
      "follow me",
      "come unto me",
      "my father"
    ];
    const lowerText = text.toLowerCase();
    return jesusIndicators.some((indicator) => lowerText.includes(indicator.toLowerCase()));
  }
  queryVerses(book, chapter, translation) {
    let results = this.getAllVersesWithMetadata();
    if (book) {
      results = results.filter((v) => v.book === book);
    }
    if (chapter) {
      results = results.filter((v) => v.chapter === chapter);
    }
    if (translation) {
      results = results.filter((v) => v.translation === translation);
    }
    return results.slice(0, 1e3);
  }
  isJesusWord(word) {
    const jesusWords = ["Jesus", "Christ", "Lord", "Master", "Rabbi", "Teacher"];
    return jesusWords.some((w) => word.includes(w));
  }
  generateBibleGatewayUrl(reference, translation) {
    const translationMap = {
      "KJV": "KJV",
      "ASV": "ASV",
      "WEB": "WEB",
      "YLT": "YLT",
      "BBE": "BBE",
      "BSB": "BSB",
      "CPDV": "CPDV",
      "SpaRV": "RVR1909",
      "Vulgate": "VULGATE",
      "Byz": "BYZ",
      "WLC": "WLC"
    };
    const bibleGatewayTranslation = translationMap[translation] || translation;
    const encodedReference = encodeURIComponent(reference);
    return `https://www.biblegateway.com/passage/?search=${encodedReference}&version=${bibleGatewayTranslation}`;
  }
};
/*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
